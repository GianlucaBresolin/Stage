\chapter{Progettazione}
\label{chap:progettazione}
Nel presente capitolo verrà presentata l'attività di progettazione relativa al progetto di stage focalizzato sul refactoring e
sull'ottimizzazione dello SDK impiegato dall'azienda \textit{Datasoil S.r.l.} per lo sviluppo di dashboard dinamiche.
Verrà analizzato l'approccio adottato per individuare le soluzioni volte al soddisfacimento dei requisiti individuati durante
la fase di analisi dei requisiti, proseguendo con la descrizione dell'architettura progettata per la realizzazione della libreria grafica \textit{viz-lib}
appartenente al \textit{development kit}, concludendo con la definizione dei tipi e delle interfacce e la progettazione delle singole componenti individuate.

\section{Metodologia di progettazione}
La metodologia di progettazione adottata durante lo svolgimento del progetto di stage ha seguito inizialmente un approccio
\textit{top-down}, che permettesse, attraverso uno studio generale della libreria preesistente e della sua architettura, di individuare
il flusso di dati tra le varie componenti, fornendo una visione globale delle interazioni e delle dipendenze esistenti.
Successivamente, è stato adottato un approccio \textit{bottom-up}, analizzando le singole componenti e le loro funzionalità,
in modo da identificare le possibili ottimizzazioni e le modifiche necessarie per il miglioramento delle prestazioni, della leggibilità e
della manutenibilità del codice.\newline
L'attività di progettazione è stata condotta in collaborazione stretta con il tutor aziendale, il quale ha fornito supporto e orientamento
riguardo alle decisioni progettuali individuate.

\section{Design dell'architettura}
L'architettura progettata per la realizzazione della libreria grafica si basa su un pattern comunemente utilizzato nello sviluppo di \textit{packages}
di componenti \textit{frontend} per \textit{React}, ovvero il pattern \textit{Component Library Architecture}: questa architettura si basa sulla creazione di una libreria di
componenti riutilizzabili, modulari e indipendenti tra loro. \newline
Tale pattern permette di creare l'architettura ideale per librerie che offrono collezioni di componenti riutilizzabili, permettendo e agevolando
la condivisione e il riutilizzo di codice all'interno del progetto, garantendo una maggior manutenibilità del codice. \newline
Il modello proposto prevede la seguente struttura, la quale si riflette nella definizione delle \textit{macro-directory} all'interno del progetto:
\begin{itemize}
      \item \textbf{components}: \textit{directory} contenente i componenti della libreria grafica;
      \item \textbf{hooks}: \textit{directory} contenente i \textit{custom hooks} utilizzati all'interno della libreria grafica;
      \item \textbf{utils}: \textit{directory} contenente le funzioni di utilità utilizzate all'interno della libreria grafica;
      \item \textbf{models}: \textit{directory} contenente le definizioni dei tipi e delle interfacce utilizzate all'interno della libreria grafica;
      \item \textbf{index.ts}: file principale della libreria grafica, contenente l'esportazione di tutti i componenti e le funzioni utilizzate;
      \item \textbf{style.css}: file contenente i fogli di stile globali utilizzati all'interno della libreria grafica.
\end{itemize}
L'\textit{entry point} della libreria grafica è il file \textit{index.ts}, il quale si occupa di esportare il \texttt{Renderer}, il componente principale
della liberia che si occupa di renderizzare il corretto componente a seconda del tipo di visualizzazione richiesto: tali informazioni necessarie
vengono passate come \textit{props} dalle componenti del modulo \textit{dashboard} che utilizzano il \texttt{Renderer}, riducendo così la dipendenza tra le
componenti di librerie differenti, agevolando la manutenibilità e la scalabilità del codice.


\section{Progettazione dei tipi e delle interfacce}
Nella seguente sezione vengono presentati i tipi e le interfacce definiti durante l'attività di progettazione, associati ad una descrizione dettagliata
delle informazioni che rappresentano. \\
La definizione dei tipi e delle interfacce ha costituito un ruolo fondamentale durante l'attività di progettazione, consentendo di raggiungere una maggior
leggibilità e manutenibilità del codice, permettendo di usufruire a pieno dei vantaggi offerti da \textit{TypeScript}. \\
I tipi e le interfacce verranno presentati in ordine alfabetico.

\subsection{ChartBaseVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione comuni a tutti i \texttt{Chart}.
\begin{minted}{typescript}
export interface ChartBaseVisualizationOptions {
      globalSeriesType: string; 
      sortX: boolean;
      sortY?: boolean;
      legend: {
      enabled: boolean;
      placement: string;
      traceorder: 'grouped'|'normal'|'reversed'|'reversed+grouped';
      };
      xAxis: {
      labels: {
            enabled: boolean;
      };
      type: string;
      title?: {
            text: string;
      };
      };
      yAxis: [
      {
            type: string;
            rangeMax?: number;
            rangeMin?: number;
            title?: {
            text?: string;
            };
      },
      {
            opposite: boolean;
            type: string;
      },
      ];
      alignYAxesAtZero: boolean;
      error_y: {
      type: string;
      visible: boolean;
      };
      series: {
      error_y: {
            type: string;
            visible: boolean;
      };
      stacking: string;
      percentValues?: boolean;
      };
      seriesOptions: {
      [x: string]: any;
      };
      valuesOptions: {
      [x: string]: any;
      };
      columnMapping: { [x: string]: string };
      direction: {
      type: string;
      };
      sizemode: string;
      coefficient: number;
      showDataLabels: boolean;
      numberFormat: string;
      dateTimeFormat: string;
      percentFormat: string;
      textFormat: string;
      missingValuesAsZero: boolean;
      onHover?: () => void;
      onUnHover?: () => void;
      reverseX?: boolean;
      reverseY?: boolean;
      showpoints?: boolean;
      heatMinColor?: string;
      heatMaxColor?: string;
      colorScheme: string | (string | number)[][];
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia \texttt{ChartBaseVisualizationOptions}}
      \label{listing:chartBaseVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{globalSeriesType}: stringa che definisce il tipo di \textit{chart} da renderizzare. I valori possibili sono i seguenti:
            \textit{area, column, box, bubble, heatmap, line, pie} e \textit{scatter};
      \item \textbf{sortX}: booleano che definisce se ordinare o meno le serie sull'asse delle ascisse;
      \item \textbf{sortY}: booleano che definisce se ordinare o meno le serie sull'asse delle ordinate;
      \item \textbf{legend}: oggetto che definisce le opzioni della legenda del grafico:
            \begin{itemize}
                  \item \textbf{enabled}: booleano che definisce se abilitare o meno la legenda;
                  \item \textbf{placement}: stringa che definisce la posizione della legenda all'interno del grafico;
                  \item \textbf{traceorder}: stringa che definisce l'ordine delle tracce all'interno del grafico.
            \end{itemize}
      \item \textbf{xAxis}: oggetto che definisce le opzioni dell'asse delle ascisse.
            \begin{itemize}
                  \item \textbf{labels}: oggetto che definisce le opzioni delle label dell'asse delle ascisse;
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ascisse;
                  \item \textbf{title}: oggetto che definisce il titolo dell'asse delle ascisse.
            \end{itemize}
      \item \textbf{yAxis}: array che definisce le opzioni dell'asse delle ordinate. Ogni elemento dell'array è un oggetto che definisce le opzioni per una serie di dati. \newline
            Il primo oggetto definisce i valori per la serie principale:
            \begin{itemize}
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ordinate;
                  \item \textbf{rangeMax}: numero che definisce il valore massimo dell'asse delle ordinate;
                  \item \textbf{rangeMin}: numero che definisce il valore minimo dell'asse delle ordinate;
                  \item \textbf{title}: oggetto che definisce il titolo dell'asse delle ordinate.
            \end{itemize}
            Il secondo oggetto definisce i valori per la serie secondaria:
            \begin{itemize}
                  \item \textbf{opposite}: booleano che definisce se la serie secondaria è opposta alla serie principale;
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ordinate.
            \end{itemize}
      \item \textbf{alignYAxesAtZero}: booleano che definisce se allineare le ordinate a zero;
      \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate.
            \begin{itemize}
                  \item \textbf{type}: stringa che definisce il tipo di errore;
                  \item \textbf{visible}: booleano che definisce se visualizzare o meno gli errori.
            \end{itemize}
      \item \textbf{series}: oggetto che definisce le opzioni delle serie.
            \begin{itemize}
                  \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate;
                  \item \textbf{stacking}: stringa che definisce se le serie sono sovrapposte o impilate;
                  \item \textbf{percentValues}: booleano che definisce se visualizzare i valori in percentuale.
            \end{itemize}
      \item \textbf{seriesOptions}: oggetto che definisce le opzioni delle serie;
      \item \textbf{valuesOptions}: oggetto che definisce le opzioni dei valori;
      \item \textbf{columnMapping}: oggetto che definisce il \textit{mapping} delle colonne;
      \item \textbf{direction}: oggetto che definisce tramite \textit{type} la direzione del grafico;
      \item \textbf{sizemode}: stringa che definisce la modalità di dimensionamento;
      \item \textbf{coefficient}: numero che definisce il coefficiente di dimensionamento;
      \item \textbf{showDataLabels}: booleano che definisce se visualizzare o meno le label dei dati;
      \item \textbf{numberFormat}: stringa che definisce il formato dei numeri;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data;
      \item \textbf{percentFormat}: stringa che definisce il formato percentuale;
      \item \textbf{textFormat}: stringa che definisce il formato del testo;
      \item \textbf{missingValuesAsZero}: booleano che definisce se i valori mancanti devono essere considerati come zero;
      \item \textbf{onHover}: funzione che definisce l'azione da eseguire al passaggio del mouse;
      \item \textbf{onUnHover}: funzione che definisce l'azione da eseguire al passaggio del mouse;
      \item \textbf{reverseX}: booleano che definisce se invertire l'asse delle ascisse;
      \item \textbf{reverseY}: booleano che definisce se invertire l'asse delle ordinate;
      \item \textbf{showpoints}: booleano che definisce se visualizzare o meno i punti;
      \item \textbf{heatMinColor}: stringa che definisce il colore minimo del grafico \textit{heatmap};
      \item \textbf{heatMaxColor}: stringa che definisce il colore massimo del grafico \textit{heatmap};
      \item \textbf{colorScheme}: stringa o array che definisce lo schema dei colori del grafico \textit{heatmap}.
\end{itemize}

\subsection{Column}
Interfaccia che definisce i tipi dei dati relativi alle colonne della tabella.

\begin{minted}{typescript}
export interface Column {
      title: string;
      name: string;
      type: string;
      visible: boolean;
      displayAs: string;
      header?: any;
      alignContent?: string;
      allowHTML?: boolean; 
      allowSearch?: boolean;
      booleanValues?: string[];
      highlightLinks?: boolean;
      imageTitleTemplate?: string;
      imageUrlTemplate?: string;
      imageWidth?: string;
      imageHeight?: string;
      linkOpenInNewTab?: boolean;
      linkTextTemplate?: string;
      linkTitleTemplate?: string;
      linkUrlTemplate?: string;
      numberFormat?: string;
      dateTimeFormat?: string;
      order?: number;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia \texttt{Column}}
      \label{listing:column}
\end{listing}
\begin{itemize}
      \item \textbf{title}: stringa che definisce il titolo della colonna;
      \item \textbf{name}: stringa che definisce il nome della colonna;
      \item \textbf{type}: stringa che definisce il tipo di dato della colonna;
      \item \textbf{visible}: booleano che definisce se la colonna è visibile o meno;
      \item \textbf{displayAs}: stringa che definisce il tipo di visualizzazione della colonna;
      \item \textbf{header}: oggetto che definisce l'header della colonna;
      \item \textbf{alignContent}: stringa che definisce l'allineamento del contenuto della colonna;
      \item \textbf{allowHTML}: booleano che definisce se permettere o meno l'utilizzo di HTML;
      \item \textbf{allowSearch}: booleano che definisce se permettere o meno la ricerca;
      \item \textbf{booleanValues}: array di stringhe che definisce i valori booleani;
      \item \textbf{highlightLinks}: booleano che definisce se evidenziare i link;
      \item \textbf{imageTitleTemplate}: stringa che definisce il template del titolo dell'immagine;
      \item \textbf{imageUrlTemplate}: stringa che definisce il template dell'URL dell'immagine;
      \item \textbf{imageWidth}: stringa che definisce la larghezza dell'immagine;
      \item \textbf{imageHeight}: stringa che definisce l'altezza dell'immagine;
      \item \textbf{linkOpenInNewTab}: booleano che definisce se aprire il link in una nuova scheda;
      \item \textbf{linkTextTemplate}: stringa che definisce il template del testo del link;
      \item \textbf{linkTitleTemplate}: stringa che definisce il template del titolo del link;
      \item \textbf{linkUrlTemplate}: stringa che definisce il template dell'URL del link;
      \item \textbf{numberFormat}: stringa che definisce il formato numerico;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data;
      \item \textbf{order}: numero che definisce l'ordine della colonna.
\end{itemize}

\subsection{CounterVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione del componente \texttt{Counter}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface CounterBaseVisualizationOptions {
            counterLabel: string;
            counterColName: string;
            targetColName?: string;
            rowNumber: number;
            targetRowNumber: number;
            countRows?: any;
            stringDecimal: number;
            stringDecChar: string;
            stringThouSep: string;
            tooltipFormat: string;
            stringPrefix?: string;
            stringSuffix?: string;
            formatTargetValue?: boolean;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia \texttt{CounterVisualizationOptions}}
      \label{listing:counterVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{counterLabel}: stringa che definisce l'etichetta del contatore;
      \item \textbf{counterColName}: stringa che definisce il nome della colonna contenente i valori del contatore;
      \item \textbf{targetColName}: stringa che definisce il nome della colonna contenente il valore target del contatore;
      \item \textbf{rowNumber}: numero che definisce il numero di righe da considerare per il calcolo del contatore;
      \item \textbf{targetRowNumber}: numero che definisce il numero di righe da considerare per il calcolo del valore target;
      \item \textbf{countRows}: oggetto che definisce le righe da considerare per il calcolo del contatore;
      \item \textbf{stringDecimal}: numero che definisce il numero di cifre decimali da visualizzare;
      \item \textbf{stringDecChar}: stringa che definisce il separatore decimale;
      \item \textbf{stringThouSep}: stringa che definisce il separatore delle migliaia;
      \item \textbf{tooltipFormat}: stringa che definisce il formato del \textit{tooltip};
      \item \textbf{stringPrefix}: stringa che definisce il prefisso del contatore;
      \item \textbf{stringSuffix}: stringa che definisce il suffisso del contatore;
      \item \textbf{formatTargetValue}: booleano che definisce se formattare o meno il valore target.
\end{itemize}

\subsection{DataLabels}
Interfaccia che definisce i tipi dei dati relativi alle label dei dati utilizzati negli \textit{heatmaps}.

\begin{minted}{typescript}
export interface DataLabels {
  x: any[];
  y: any[];
  mode: string;
  hoverinfo: string;
  showlegend: boolean;
  text: string[];
  textfont: {
    color: string[];
  };
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia \texttt{DataLabels}}
      \label{listing:dataLabels}
\end{listing}
\begin{itemize}
      \item \textbf{x}: array che definisce i valori sull'asse delle ascisse;
      \item \textbf{y}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{mode}: stringa che definisce la modalità;
      \item \textbf{hoverinfo}: stringa che definisce le informazioni del \textit{tooltip};
      \item \textbf{showlegend}: booleano che definisce se visualizzare o meno la legenda;
      \item \textbf{text}: array di stringhe che definisce il testo;
      \item \textbf{textfont}: oggetto che definisce le opzioni del font del testo:
            \begin{itemize}
                  \item \textbf{color}: array di stringhe che definisce i colori del font.
            \end{itemize}
\end{itemize}

\subsection{PlotlyOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione di \textit{Plotly.js}.
\begin{minted}{typescript}
export interface PlotlyOptions {
  showLink: boolean;
  displaylogo: boolean;
  displayModeBar?: boolean;
  responsive?: boolean;
  autosize?: boolean;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia \texttt{PlotlyOptions}}
      \label{listing:plotlyOptions}
\end{listing}
\begin{itemize}
      \item \textbf{showLink}: booleano che definisce se visualizzare o meno il link;
      \item \textbf{displaylogo}: booleano che definisce se visualizzare o meno il logo;
      \item \textbf{displayModeBar}: booleano che definisce se visualizzare o meno la barra di \textit{Plotly};
      \item \textbf{responsive}: booleano che definisce se rendere o meno il grafico responsivo;
      \item \textbf{autosize}: booleano che definisce se adattare o meno la grandezza del grafico.
\end{itemize}

\subsection{RendererProps}
Interfaccia che definisce i tipi dei dati passati alla componenti \texttt{Renderer, Counter, Chart} e \texttt{Table}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface RendererProps {
            type: string;
            visualizationName: string;
            data: {
                  [x: string]: any;
            };
            options: VisualizationOptions;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia \texttt{RendererProps}}
      \label{listing:rendererProps}
\end{listing}
\begin{itemize}
      \item \textbf{type}: stringa che definisce il tipo componente da renderizzazre. Può assumere i seguenti valori: \textit{COUNTER}, \textit{CHART} e \textit{TABLE};
      \item \textbf{visualizationName}: stringa che definisce il titolo di visualizzazione della componente;
      \item \textbf{data}: oggetto che contiene i dati da visualizzare all'interno della componente;
      \item \textbf{options}: oggetto che contiene le opzioni di visualizzazione della componente di tipo \textit{VisualizationOptions}.
\end{itemize}

\subsection{Series}
Interfaccia che definisce i tipi dei dati relativi alle serie rappresentata nel grafico.
\begin{minted}{typescript}
export interface Series {
  name: string;
  type: string;
  data?: any[];
  visible?: boolean;
  values?: number[];
  labels?: string[];
  hole?: number;
  marker?: {
    colors?: string[];
    color?: string; 
    line?: {
      color?: string;
      width?: number;
    };
    size?: number;
    sizemode?: string;
  };
  hoverinfo?: string | boolean;
  text?: any[];
  textinfo?: string;
  textposition?: string;
  textangle?: number;
  textfont?: {
    size?: number;
    color?: string[];
  };
  direction?: string;
  domain?: {
    x: number[];
    y: number[];
  };
  sourceData?: Map<string, any>;
  hoverlabel?: {
    font?: {
      color?: string[];
    };
    bordercolor?: string;
    bgcolor?: string;
  };
  hover?: any[];
  x?: any;
  y?: any;
  z?: any;
  yaxis?: any;
  orientation?: number;
  insidetextfont?: {
    size?: number;
    color?: string;
  };
  error_y?: any;
  offsetgroup?: string;
  mode?: string;
  fill?: string;
  boxpoints?: string;
  jitter?: number;
  pointpos?: number;
  colorscale?: string | (string | number)[][];
  xgap?: number;
  ygap?: number;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia \texttt{Series}}
      \label{listing:series}
\end{listing}
\begin{itemize}
      \item \textbf{name}: stringa che definisce il nome della serie;
      \item \textbf{type}: stringa che definisce il tipo di serie;
      \item \textbf{data}: array che definisce i dati della serie;
      \item \textbf{visible}: booleano che definisce se la serie è visibile o meno;
      \item \textbf{values}: array di numeri che definisce i valori della serie;
      \item \textbf{labels}: array di stringhe che definisce le label della serie;
      \item \textbf{hole}: numero che definisce, nel caso di grafico a torta, il raggio del buco centrale;
      \item \textbf{marker}: oggetto che definisce le opzioni del \textit{marker};
      \item \textbf{hoverinfo}: stringa o booleano che definisce le informazioni del \textit{tooltip};
      \item \textbf{text}: array che definisce il testo della serie;
      \item \textbf{textinfo}: stringa che definisce le informazioni del testo;
      \item \textbf{textposition}: stringa che definisce la posizione del testo;
      \item \textbf{textangle}: numero che definisce l'angolo del testo;
      \item \textbf{textfont}: oggetto che definisce le opzioni del font del testo;
      \item \textbf{direction}: stringa che definisce la direzione della serie;
      \item \textbf{domain}: oggetto che definisce il dominio della serie;
      \item \textbf{sourceData}: mappa che definisce i dati sorgente;
      \item \textbf{hoverlabel}: oggetto che definisce le opzioni del \textit{tooltip};
      \item \textbf{hover}: array che definisce le opzioni del \textit{tooltip};
      \item \textbf{x}: array che definisce i valori sull'asse delle ascisse;
      \item \textbf{y}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{z}: array che definisce i valori sull'asse z;
      \item \textbf{yaxis}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{orientation}: numero che definisce l'orientamento;
      \item \textbf{insidetextfont}: oggetto che definisce le opzioni del font interno;
      \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate;
      \item \textbf{offsetgroup}: stringa che definisce il gruppo di \textit{offset};
      \item \textbf{mode}: stringa che definisce la modalità;
      \item \textbf{fill}: stringa che definisce il riempimento;
      \item \textbf{boxpoints}: stringa che definisce i punti del \textit{box};
      \item \textbf{jitter}: numero che definisce il \textit{jitter} (variazione);
      \item \textbf{pointpos}: numero che definisce la posizione del punto;
      \item \textbf{colorscale}: stringa o array che definisce lo schema dei colori;
      \item \textbf{xgap}: numero che definisce il gap sull'asse delle ascisse;
      \item \textbf{ygap}: numero che definisce il gap sull'asse delle ordinate;
      \item \textbf{colors}: array di stringhe che definisce i colori del \textit{marker};
      \item \textbf{color}: stringa che definisce il colore del \textit{marker};
      \item \textbf{line}: oggetto che definisce le opzioni della linea del \textit{marker};
      \item \textbf{size}: numero che definisce la grandezza del \textit{marker};
      \item \textbf{sizemode}: stringa che definisce la modalità di dimensionamento del \textit{marker}.
      \item \textbf{font}: oggetto che definisce le opzioni del font del \textit{marker};
      \item \textbf{bordercolor}: stringa che definisce il colore del bordo del \textit{marker};
      \item \textbf{bgcolor}: stringa che definisce il colore di sfondo del \textit{marker};
      \item \textbf{colors}: array di stringhe che definisce i colori delle rappresentazioni (multiple);
      \item \textbf{size}: numero che definisce la grandezza del font;
      \item \textbf{color}: stringa che definisce il colore della rappresentazione (singola).
\end{itemize}

\subsection{TableBaseVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione del componente \texttt{Table}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface TableBaseVisualizationOptions {
            columns?: Column[];
            itemsPerPage?: number;
            paginationSize?: string;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia \texttt{TableBaseVisualizationOptions}}
      \label{listing:tableBaseVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{columns}: array di oggetti che definiscono le colonne della tabella;
      \item \textbf{itemsPerPage}: numero che definisce il numero di elementi per pagina;
      \item \textbf{paginationSize}: stringa che definisce la grandezza della paginazione.
\end{itemize}

\subsection{VisualizationOptions}
Tipo che definisce le opzioni di visualizzazione delle componenti.
\begin{listing}[H]
      \begin{minted}{typescript}
      export type VisualizationOptions = 
            | CounterBaseVisualizationOptions 
            | ChartBaseVisualizationOptions 
            | TableBaseVisualizationOptions;
      \end{minted}
      \caption{Definizione del tipo \texttt{VisualizationOptions}}
      \label{listing:visualizationOptions}
\end{listing}
Questa definizione permette di definire le opzioni di visualizzazione specifiche per ciascun tipo di componente, garantendo una maggiore flessibilità
nella definizione di \texttt{RendererProps}.

\subsection{VisualizationSettings}
Interfaccia che definisce i tipi dei dati relativi alle impostazioni di visualizzazione delle componenti.
\begin{listing}[H]
      \begin{minted}{typescript}
      interface VisualizationSettings {
            dateFormat: string;
            dateTimeFormat: string;
            integerFormat: string;
            floatFormat: string;
            booleanValues: string[];
            tableCellMaxJSONSize: number;
            allowCustomJSVisualizations: boolean;
            hidePlotlyModeBar: boolean;
            choroplethAvailableMaps: any;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia \texttt{VisualizationSettings}}
      \label{listing:visualizationSettings}
\end{listing}
\begin{itemize}
      \item \textbf{dateFormat}: stringa che definisce il formato della data;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data e dell'ora;
      \item \textbf{integerFormat}: stringa che definisce il formato degli interi;
      \item \textbf{floatFormat}: stringa che definisce il formato dei numeri decimali;
      \item \textbf{booleanValues}: array di stringhe che definisce i valori booleani;
      \item \textbf{tableCellMaxJSONSize}: numero che definisce la grandezza massima delle celle della tabella;
      \item \textbf{allowCustomJSVisualizations}: booleano che definisce se permettere o meno le visualizzazioni personalizzate;
      \item \textbf{hidePlotlyModeBar}: booleano che definisce se nascondere o meno la barra di Plotly;
      \item \textbf{choroplethAvailableMaps}: oggetto che definisce le mappe disponibili per il choropleth.
\end{itemize}

\subsection{VisualizationType}
Enumerazione che definisce i possibili valori dei tipi di visualizzazione supportati dalla libreria grafica.
\begin{listing}[H]
      \begin{minted}{typescript}
      export enum VisualizationType {
            Counter = 'COUNTER',
            Chart = 'CHART',
            Table = 'TABLE',
            None = 'NONE',
      }
      \end{minted}
      \caption{Definizione dell'enumerazione \texttt{VisualizationType}}
      \label{listing:visualizationType}
\end{listing}
I possibili valori dell'enumerazione sono i seguenti:
\begin{itemize}
      \item \textbf{Counter}: componente che visualizza un contatore;
      \item \textbf{Chart}: componente che visualizza un grafico;
      \item \textbf{Table}: componente che visualizza una tabella;
      \item \textbf{None}: valore di default, utilizzato per la gestione di errori o situazioni non previste.
\end{itemize}

\section{Progettazione delle componenti}
Nella seguente sezione verranno presentate le componenti individuate durante l'attività di progettazione, con una descrizione dettagliata delle
funzionalità offerte e delle possibili ottimizzazioni individuate. \newline
L'attività di progettazione è avvenuta seguendo il \textit{single responsability principle}, invididuando componenti operabili all'interno
del design pattern \textit{Component Composition} proprio di \textit{React}, il quale prevede la combinazione di composizioni di componenti più piccole
per ottenere componenti più complesse, favorendo il riutilizzo, la modularità e la manutenibilità del codice. \newline
Le componenti verranno presentate in ordine alfabetico, secondo la seguente struttura:
\begin{itemize}
      \item \textbf{Nome della componente}: breve descrizione della componente;
      \item \textbf{Descrizione}: descrizione dettagliata delle funzionalità offerte dalla componente;
      \item \textbf{Props}: definizione delle props utilizzate dalla componente;
      \item \textbf{Ottimizzazioni}: possibili ottimizzazioni individuate per la componente.
\end{itemize}

\subsection{Counter}
\begin{itemize}
      \item \textbf{Nome della componente}: \texttt{Counter};
      \item \textbf{Descrizione}: La componente \texttt{Counter} prevede la visualizzazione di un contatore, il cui valore viene definito a partire dai dati passati
            come \textit{props} tra le varie componenti e forniti dalla risposta in formato \textit{JSON} ricevuta dai \textit{server Datasoil}. \newline
            La componente permette inoltre di confrontare il valore attuale del contatore con un valore target (opzionale) da raggiungere, anch'esso ricavato
            dalla risposta in formato \textit{JSON} ricevuta dal \textit{server}. \newline
            Il valore del contatore può essere formattato in base alle preferenze definite lato backend, presentando le seguenti opzioni:
            \begin{itemize}
                  \label{counter-format}
                  \item Prefisso: stringa da aggiungere prima del valore del contatore;
                  \item Suffisso: stringa da aggiungere dopo il valore del contatore;
                  \item Numero di cifre decimali: numero di cifre decimali da visualizzare nel valore del contatore;
                  \item Separatore delle migliaia: carattere da utilizzare come separatore delle migliaia;
                  \item Separatore decimale: carattere da utilizzare come separatore decimale.
            \end{itemize}
            (Queste formattazioni sono applicabili anche al valore target e ai \textit{tooltip} visualizzati al passaggio del mouse sul contatore).\\
            L'implementazione delle formattazioni numeriche prevede l'utilizzo della libreria \textit{numbro.js}.
      \item \textbf{Props}: I \textit{props} della componente \texttt{Counter} sono definiti dall'interfaccia \\
            \texttt{RendererProps}, su cui il componente ne effettua il \textit{picking}
            (ovvero la selezione) delle informazioni \textit{data, options} e \textit{visualizationName}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Counter({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
                  \caption{Definizione delle \textit{props} della componente \texttt{Counter}}
                  \label{listing:counterProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo della libreria \textit{numbro.js} a favore della libreria \textit{numeral.js} precedentemente utilizzata, più pesante e non più mantenuta,
                        per la formattazione delle label numeriche all'interno del \texttt{Counter};
                  \item La progettazione della presente componente prevede l'utilizzo di \textit{hooks} per la gestione del suo stato interno e per il calcolo delle dimensioni
                        del contatore, necessarie per permettere la visualizzazione responsiva della componente: l'utilizzo di tali \textit{hooks} permette di garantire
                        un'implementazione efficiente e performante, riducendo il numero di renderizzazioni e computazioni non necessarie.
            \end{itemize}
\end{itemize}

\subsection{Chart}
\begin{itemize}
      \item \textbf{Nome della componente}: \texttt{Chart};
      \item \textbf{Descrizione}: La componente \texttt{Chart} prevede la visualizzazione di un grafico, il cui tipo e i dati da visualizzare vengono definiti a partire dai dati passati
            come \textit{props} tra le varie componenti e forniti dalla risposta in formato \textit{JSON} ricevuta dai \textit{server Datasoil}. \newline
            I tipi di grafici che tale componente permette di renderizzare sono i seguenti:
            \begin{itemize}
                  \item \textit{Area Chart}: grafico ad area;
                  \item \textit{Bar Chart}: grafico a barre;
                  \item \textit{Box Plot Chart}: grafico a scatola;
                  \item \textit{Bubble Chart}: grafico a bolle;
                  \item \textit{HeatMap Chart}: grafico a matrice;
                  \item \textit{Line Chart}: grafico a linee;
                  \item \textit{Pie Chart}: grafico a torta;
                  \item \textit{Scatter Chart}: grafico a dispersione.
            \end{itemize}
            La componente permette inoltre, a seconda del tipo di grafico renderizzato, di:
            \begin{itemize}
                  \item Effettuare il download dell'immagine del grafico in formato \textit{.png};
                  \item Effettuare lo zoom sul grafico;
                  \item Effettuare lo zoom-in sul grafico;
                  \item Effettuare lo zoom-out sul grafico;
                  \item Effettuare il pan sul grafico;
                  \item Effettuare l'autoscale sul grafico;
                  \item Resettare la dimensione degli assi del grafico.
            \end{itemize}
            A fronte di tali funzionalità, l'implementazione della componente prevede l'utilizzo della libreria \textit{Plotly.js}, la quale permette
            di renderizzare grafici in modo reattivo. \newline
            Le evenutali label applicate ai grafici possono essere formattate in base alle preferenze definite lato backend, presentando le seguenti opzioni. \newline
            \begin{itemize}
                  \item Label numeriche:
                        \begin{itemize}
                              \item Numero di cifre decimali: numero di cifre decimali da visualizzare nel valore della label;
                              \item Separatore delle migliaia: carattere da utilizzare come separatore delle migliaia;
                              \item Separatore decimale: carattere da utilizzare come separatore decimale;
                              \item suffissi: stringa da aggiungere dopo il valore della label, ad esempio '\textit{\%}'.
                        \end{itemize}
                        L'implementazione delle formattazioni numeriche prevede l'utilizzo della libreria \textit{numbro.js}. \newline
                  \item Label temporali:
                        \begin{itemize}
                              \item Formato della data: formato da utilizzare per la visualizzazione della data;
                              \item Formato dell'ora: formato da utilizzare per la visualizzazione dell'ora.
                        \end{itemize}
                        L'implementazione delle formattazioni temporali prevede l'utilizzo della liberia \textit{day.js}.
            \end{itemize}
      \item \textbf{Props}: I \textit{props} della componente \texttt{Chart} sono definiti dall'interfaccia \\
            \texttt{RendererProps}, su cui il componente ne effettua il \textit{picking}
            delle informazioni \textit{data} e \textit{options}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Chart({
                        data,
                        options,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options'>);
                  \end{minted}
                  \caption{Definizione delle \textit{props} della componente \texttt{Chart}}
                  \label{listing:chartProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo di un \textit{custom bundle} di \textit{Plotly.js} in modo da ridurre le dimensioni del \textit{bundle} finale, evitando la registrazione
                        di grafici non utilizzati all'interno delle dashboard \textit{Datasoil S.r.l.} Tale ottimizzazione permette inoltre di evitare la registrazione
                        manuale delle \textit{traces}, necessaria nelle versioni rese disponibili da \textit{Plotly.js} a causa di un bug noto non risolto della libreria.
                  \item Utilizzo della libreria \textit{numbro.js} a favore della libreria \textit{numeral.js} precedentemente utilizzata, più pesante e non più mantenuta,
                        per la formattazione delle label numeriche all'interno dei grafici;
                  \item Utilizzo della libreria \textit{day.js} a favore della libreria \textit{moment.js} precedentemente utilizzata, in quanto costituisce una
                        \textit{peerdependency} all'interno dei prodotti \textit{Datasoil S.r.l.}, riducendo così le dimensioni del \textit{bundle} finale;
                  \item Utilizzo di un \textit{custom hooks} per la gestione dello stato interno della componente e per il calcolo delle dimensioni del grafico, necessarie per permettere
                        la visualizzazione responsiva della componente. L'utilizzo dell'\textit{hooks} è volto a garantire un'implementazione efficiente e performante della componente.
            \end{itemize}
\end{itemize}

\subsection{Table}
\begin{itemize}
      \item \textbf{Nome della componente}: \texttt{Table};
      \item \textbf{Descrizione}: La componente \texttt{Table} prevede la visualizzazione di una tabella, i cui dati e la cui struttura (intesa come colonne e tipo di dato visualizzato
            all'interno di esse) vengono definiti a partire dai dati passati come \textit{props} tra le varie componenti e forniti dalla risposta in formato \textit{JSON} ricevuta dai \textit{server Datasoil}. \newline
            La componente permette inoltre di:
            \begin{itemize}
                  \item Ordinare le colonne della tabella;
                  \item Filtrare le \textit{entry} della tabella grazie ad un filtro globale;
                  \item Effettuare il download della tabella in formato \textit{.csv};
            \end{itemize}
            A fronte di tali funzionalità, l'implementazione della componente prevede l'utilizzo della componente fornita dalla libreria \textit{PrimeReact}.
      \item \textbf{Props}: I \textit{props} della componente \texttt{Table} sono definiti dall'interfaccia \\
            \texttt{RendererProps}, su cui il componente ne effettua il \textit{picking}
            delle informazioni \textit{data, options} e \textit{visualizationName}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Table({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
                  \caption{Definizione delle \textit{props} della componente \texttt{Table}}
                  \label{listing:tableProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo della componente \texttt{DataTable} fornita dalla libreria \textit{PrimeReact} a favore della componente \texttt{Table} di \textit{AntD} precedentemente utilizzata,
                        in quanto la libreria \textit{PrimeReact} offre una maggiore flessibilità e personalizzazione delle tabelle, oltre che a costituire una \textit{peerdependency} all'interno dei
                        prodotti \textit{Datasoil S.r.l.}, riducendo così le dimensioni del \textit{bundle} finale;
                  \item Utilizzo di \textit{hook} per la gestione del filtro globale, in modo da garantire un'implementazione efficiente e performante della componente, a differenza dell'implementazione
                        fornita da \textit{PrimeReact} che comporta un bug noto non risolto. \label{item:hookTable}
            \end{itemize}
\end{itemize}

\subsection{Renderer}
\begin{itemize}
      \item \textbf{Nome della componente}: \texttt{Renderer};
      \item \textbf{Descrizione}: La componente \texttt{Renderer} seleziona dinamicamente un sottocomponente tra quelli resi disponibili dalla libreria \textit{viz-lib}
            in base al tipo di visualizzazione definito nei dati passati come \textit{props}, costituendo l'\textit{entry point} della libreria. \newline
      \item \textbf{Props}: I \textit{props} della componente \texttt{Renderer} sono definiti dall'interfaccia \\
            \texttt{RendererProps}, su cui il componente ne effettua il \textit{picking}
            delle informazioni \textit{data, options} e \textit{visualizationName}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Renderer({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
                  \caption{Definizione delle \textit{props} della componente \texttt{Renderer}}
                  \label{listing:rendererPropsInComponent}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item La componente prevede l'utilizzo di \textit{hooks} per ottimizzare le prestazioni, rendendo il componente \gls{memoizzato}\glox, prevenendo i rendering
                        non necessari, garantendo così un'implementazione efficiente e performante.
            \end{itemize}
\end{itemize}

\subsection{VisualizationWidgetHeader}
\begin{itemize}
      \item \textbf{Nome della componente}: \texttt{VisualizationWidgetHeader};
      \item \textbf{Descrizione}: La componente \texttt{VisualizationWidgetHeader} appartiene alla libreria \textit{dashboard}, appartenente sempre al SDK prodotto. Questa componente costituisce l'\textit{header}
            del \textit{container} per la visualizzazione delle componenti da renderizzare all'interno della dashboard. \newline
      \item \textbf{Props}: I \textit{props} della componente \texttt{VisualizationWidgetHeader} sono definiti delle informazioni \textit{name, visualization} e \textit{dataDialog}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  function VisualizationWidgetHeader({
                        name,
                        visualization,
                        dataDialog,
                        }: {
                        name: string;
                        visualization: Visualization;
                        dataDialog: WidgetData | undefined;
                        });
                  \end{minted}
                  \caption{Definizione delle \textit{props} della componente \texttt{VisualizationWidgetHeader}}
                  \label{listing:visualizationWidgetHeaderProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Ridefinizione dei \textit{props} della componente in modo da permettere la visualizzazione di un \textit{dialog} contenente la componente visualizzata all'interno del \textit{container};
                  \item Ridefinizione della componente in modo da permettere la visualizzazione di un \textit{dialog} contenente la componente visualizzata all'interno del \textit{container}, attraverso
                        l'utilizzo di componenti fornite dalla libreria \textit{PrimeReact}.
            \end{itemize}
\end{itemize}