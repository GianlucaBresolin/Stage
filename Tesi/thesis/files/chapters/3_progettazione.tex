\chapter{Progettazione}
\label{chap:progettazione}
Nel presente capitolo viene presentata l'attività di progettazione relativa al progetto di stage focalizzato sul refactoring e
sull'ottimizzazione dello SDK impiegato dall'azienda Datasoil S.r.l. per lo sviluppo di dashboard dinamiche.
Verrà analizzato l'approccio adottato per individuare le soluzioni volte al soddisfacimento dei requisiti individuati durante
la fase di analisi dei requisiti, proseguendo con la descrizione dell'architettura progettata per la realizzazione della libreria grafica \textit{viz-lib}
appartenente al development kit, concludendo con la definizione dei tipi e delle interfacce e la progettazione delle singole componenti individuate.

\section{Metodologia di progettazione}
La metodologia di progettazione adottata durante lo svolgimento del progetto di stage ha seguito inizialmente un approccio
\textit{top-down}, che permettesse, attraverso uno studio generale della libreria preesistente e della sua architettura, di individuare
il flusso di dati tra le varie componenti, fornendo una visione globale delle interazioni e delle dipendenze esistenti.
Successivamente, è stato adottato un approccio \textit{bottom-up}, analizzando le singole componenti e le loro funzionalità,
in modo da identificare le possibili ottimizzazioni e le modifiche necessarie per il miglioramento delle prestazioni, della leggibilità e
della manutenibilità del codice.\newline
L'attività di progettazione è stata condotta in collaborazione stretta con il tutor aziendale, il quale ha fornito supporto e orientamento
riguardo alle decisioni progettuali individuate.

\section{Design dell'architettura}
L'architettura progettata per la realizzazione della libreria grafica si basa su un pattern comunemente utilizzato nello sviluppo di packages
di componenti frontend per \textit{React}, ovvero il pattern \textit{Component Library Architecture}: questa architettura si fonda sulla creazione di una libreria di
componenti riutilizzabili, modulari e indipendenti tra loro. \newline
Tale pattern permette di creare l'architettura ideale per librerie che offrono collezioni di componenti riutilizzabili, permettendo e agevolando
la condivisione e il riutilizzo di codice all'interno del progetto, garantendo una maggior manutenibilità del codice. \newline
Il modello proposto prevede la seguente struttura, la quale si riflette nella definizione delle macro-directory all'interno del progetto:
\begin{itemize}
      \item \textbf{components}: directory contenente i componenti della libreria grafica;
      \item \textbf{hooks}: directory contenente i custom hooks utilizzati all'interno della libreria grafica;
      \item \textbf{utils}: directory contenente le funzioni di utilità utilizzate all'interno della libreria grafica;
      \item \textbf{models}: directory contenente le definizioni dei tipi e delle interfacce utilizzate all'interno della libreria grafica;
      \item \textbf{index.ts}: file principale della libreria grafica, contenente l'esportazione di tutti i componenti e le funzioni utilizzate;
      \item \textbf{style.css}: file contenente i fogli di stile globali utilizzati all'interno della libreria grafica.
\end{itemize}
L'entry point della libreria grafica è il file \textit{index.ts}, il quale si occupa di esportare il \textit{Renderer}, il componente principale
della liberia che si occupa di renderizzare il corretto componente a seconda del tipo di visualizzazione richiesto: tali informazioni necessarie
vengono passate come props dalle componenti del modulo \textit{dashboard} che utilizzano il \textit{Renderer}, riducendo così la dipendenza tra le
componenti di librerie differenti, agevolando la manutenibilità e la scalabilità del codice.


\section{Progettazione dei tipi e delle interfacce}
Nella seguente sezione vengono presentati i tipi e le interfacce definiti durante l'attività di progettazione, associati ad una descrizione dettagliata
delle informazioni che rappresentano. \\
La definizione dei tipi e delle interfacce ha costituito un ruolo fondamentale durante l'attività di progettazione, permettendo di raggiungere una maggior
leggibilità e manutenibilità del codice, permettendo di usufruire a pieno dei vantaggi offerti da \textit{TypeScript}. \\
I tipi e le interfacce verranno presentati in ordine alfabetico.

\subsection{ChartBaseVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione comuni a tutti i \textit{Chart}.
\begin{minted}{typescript}
export interface ChartBaseVisualizationOptions {
      globalSeriesType: string; 
      sortX: boolean;
      sortY?: boolean;
      legend: {
      enabled: boolean;
      placement: string;
      traceorder: 'grouped'|'normal'|'reversed'|'reversed+grouped';
      };
      xAxis: {
      labels: {
            enabled: boolean;
      };
      type: string;
      title?: {
            text: string;
      };
      };
      yAxis: [
      {
            type: string;
            rangeMax?: number;
            rangeMin?: number;
            title?: {
            text?: string;
            };
      },
      {
            opposite: boolean;
            type: string;
      },
      ];
      alignYAxesAtZero: boolean;
      error_y: {
      type: string;
      visible: boolean;
      };
      series: {
      error_y: {
            type: string;
            visible: boolean;
      };
      stacking: string;
      percentValues?: boolean;
      };
      seriesOptions: {
      [x: string]: any;
      };
      valuesOptions: {
      [x: string]: any;
      };
      columnMapping: { [x: string]: string };
      direction: {
      type: string;
      };
      sizemode: string;
      coefficient: number;
      showDataLabels: boolean;
      numberFormat: string;
      dateTimeFormat: string;
      percentFormat: string;
      textFormat: string;
      missingValuesAsZero: boolean;
      onHover?: () => void;
      onUnHover?: () => void;
      reverseX?: boolean;
      reverseY?: boolean;
      showpoints?: boolean;
      heatMinColor?: string;
      heatMaxColor?: string;
      colorScheme: string | (string | number)[][];
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia ChartBaseVisualizationOptions}
      \label{listing:chartBaseVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{globalSeriesType}: stringa che definisce il tipo di chart da renderizzare. I valori possibili sono i seguenti:
            \textit{area, column, box, bubble, heatmap, line, pie} e \textit{scatter};
      \item \textbf{sortX}: booleano che definisce se ordinare o meno le serie sull'asse delle ascisse;
      \item \textbf{sortY}: booleano che definisce se ordinare o meno le serie sull'asse delle ordinate;
      \item \textbf{legend}: oggetto che definisce le opzioni della legenda del grafico.
            \begin{itemize}
                  \item \textbf{enabled}: booleano che definisce se abilitare o meno la legenda;
                  \item \textbf{placement}: stringa che definisce la posizione della legenda all'interno del grafico;
                  \item \textbf{traceorder}: stringa che definisce l'ordine delle tracce all'interno del grafico.
            \end{itemize}
      \item \textbf{xAxis}: oggetto che definisce le opzioni dell'asse delle ascisse.
            \begin{itemize}
                  \item \textbf{labels}: oggetto che definisce le opzioni delle label dell'asse delle ascisse;
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ascisse;
                  \item \textbf{title}: oggetto che definisce il titolo dell'asse delle ascisse.
            \end{itemize}
      \item \textbf{yAxis}: array che definisce le opzioni dell'asse delle ordinate. Ogni elemento dell'array è un oggetto che definisce le opzioni per una serie di dati. \newline
            Il primo oggetto definisce i valori per la serie principale:
            \begin{itemize}
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ordinate;
                  \item \textbf{rangeMax}: numero che definisce il valore massimo dell'asse delle ordinate;
                  \item \textbf{rangeMin}: numero che definisce il valore minimo dell'asse delle ordinate;
                  \item \textbf{title}: oggetto che definisce il titolo dell'asse delle ordinate.
            \end{itemize}
            Il secondo oggetto definisce i valori per la serie secondaria:
            \begin{itemize}
                  \item \textbf{opposite}: booleano che definisce se la serie secondaria è opposta alla serie principale;
                  \item \textbf{type}: stringa che definisce il tipo di dato visualizzato sull'asse delle ordinate.
            \end{itemize}
      \item \textbf{alignYAxesAtZero}: booleano che definisce se allineare le ordinate a zero;
      \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate.
            \begin{itemize}
                  \item \textbf{type}: stringa che definisce il tipo di errore;
                  \item \textbf{visible}: booleano che definisce se visualizzare o meno gli errori.
            \end{itemize}
      \item \textbf{series}: oggetto che definisce le opzioni delle serie.
            \begin{itemize}
                  \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate;
                  \item \textbf{stacking}: stringa che definisce se le serie sono sovrapposte o impilate;
                  \item \textbf{percentValues}: booleano che definisce se visualizzare i valori in percentuale.
            \end{itemize}
      \item \textbf{seriesOptions}: oggetto che definisce le opzioni delle serie;
      \item \textbf{valuesOptions}: oggetto che definisce le opzioni dei valori;
      \item \textbf{columnMapping}: oggetto che definisce il mapping delle colonne;
      \item \textbf{direction}: oggetto che definisce tramite type la direzione del grafico;
      \item \textbf{sizemode}: stringa che definisce la modalità di dimensionamento;
      \item \textbf{coefficient}: numero che definisce il coefficiente di dimensionamento;
      \item \textbf{showDataLabels}: booleano che definisce se visualizzare o meno le label dei dati;
      \item \textbf{numberFormat}: stringa che definisce il formato dei numeri;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data;
      \item \textbf{percentFormat}: stringa che definisce il formato percentuale;
      \item \textbf{textFormat}: stringa che definisce il formato del testo;
      \item \textbf{missingValuesAsZero}: booleano che definisce se i valori mancanti devono essere considerati come zero;
      \item \textbf{onHover}: funzione che definisce l'azione da eseguire al passaggio del mouse;
      \item \textbf{onUnHover}: funzione che definisce l'azione da eseguire al passaggio del mouse;
      \item \textbf{reverseX}: booleano che definisce se invertire l'asse delle ascisse;
      \item \textbf{reverseY}: booleano che definisce se invertire l'asse delle ordinate;
      \item \textbf{showpoints}: booleano che definisce se visualizzare o meno i punti;
      \item \textbf{heatMinColor}: stringa che definisce il colore minimo del grafico heatmap;
      \item \textbf{heatMaxColor}: stringa che definisce il colore massimo del grafico heatmap;
      \item \textbf{colorScheme}: stringa o array che definisce lo schema dei colori del grafico heatmap.
\end{itemize}

\subsection{Column}
Interfaccia che definisce i tipi dei dati relativi alle colonne della tabella.

\begin{minted}{typescript}
export interface Column {
      title: string;
      name: string;
      type: string;
      visible: boolean;
      displayAs: string;
      header?: any;
      alignContent?: string;
      allowHTML?: boolean; 
      allowSearch?: boolean;
      booleanValues?: string[];
      highlightLinks?: boolean;
      imageTitleTemplate?: string;
      imageUrlTemplate?: string;
      imageWidth?: string;
      imageHeight?: string;
      linkOpenInNewTab?: boolean;
      linkTextTemplate?: string;
      linkTitleTemplate?: string;
      linkUrlTemplate?: string;
      numberFormat?: string;
      dateTimeFormat?: string;
      order?: number;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia Column}
      \label{listing:column}
\end{listing}
\begin{itemize}
      \item \textbf{title}: stringa che definisce il titolo della colonna;
      \item \textbf{name}: stringa che definisce il nome della colonna;
      \item \textbf{type}: stringa che definisce il tipo di dato della colonna;
      \item \textbf{visible}: booleano che definisce se la colonna è visibile o meno;
      \item \textbf{displayAs}: stringa che definisce il tipo di visualizzazione della colonna;
      \item \textbf{header}: oggetto che definisce l'header della colonna;
      \item \textbf{alignContent}: stringa che definisce l'allineamento del contenuto della colonna;
      \item \textbf{allowHTML}: booleano che definisce se permettere o meno l'utilizzo di HTML;
      \item \textbf{allowSearch}: booleano che definisce se permettere o meno la ricerca;
      \item \textbf{booleanValues}: array di stringhe che definisce i valori booleani;
      \item \textbf{highlightLinks}: booleano che definisce se evidenziare i link;
      \item \textbf{imageTitleTemplate}: stringa che definisce il template del titolo dell'immagine;
      \item \textbf{imageUrlTemplate}: stringa che definisce il template dell'URL dell'immagine;
      \item \textbf{imageWidth}: stringa che definisce la larghezza dell'immagine;
      \item \textbf{imageHeight}: stringa che definisce l'altezza dell'immagine;
      \item \textbf{linkOpenInNewTab}: booleano che definisce se aprire il link in una nuova scheda;
      \item \textbf{linkTextTemplate}: stringa che definisce il template del testo del link;
      \item \textbf{linkTitleTemplate}: stringa che definisce il template del titolo del link;
      \item \textbf{linkUrlTemplate}: stringa che definisce il template dell'URL del link;
      \item \textbf{numberFormat}: stringa che definisce il formato numerico;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data;
      \item \textbf{order}: numero che definisce l'ordine della colonna.
\end{itemize}


\subsection{CounterVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione del componente \textit{Counter}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface CounterBaseVisualizationOptions {
            counterLabel: string;
            counterColName: string;
            targetColName?: string;
            rowNumber: number;
            targetRowNumber: number;
            countRows?: any;
            stringDecimal: number;
            stringDecChar: string;
            stringThouSep: string;
            tooltipFormat: string;
            stringPrefix?: string;
            stringSuffix?: string;
            formatTargetValue?: boolean;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia CounterVisualizationOptions}
      \label{listing:counterVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{counterLabel}: stringa che definisce l'etichetta del contatore;
      \item \textbf{counterColName}: stringa che definisce il nome della colonna contenente i valori del contatore;
      \item \textbf{targetColName}: stringa che definisce il nome della colonna contenente il valore target del contatore;
      \item \textbf{rowNumber}: numero che definisce il numero di righe da considerare per il calcolo del contatore;
      \item \textbf{targetRowNumber}: numero che definisce il numero di righe da considerare per il calcolo del valore target;
      \item \textbf{countRows}: oggetto che definisce le righe da considerare per il calcolo del contatore;
      \item \textbf{stringDecimal}: numero che definisce il numero di cifre decimali da visualizzare;
      \item \textbf{stringDecChar}: stringa che definisce il separatore decimale;
      \item \textbf{stringThouSep}: stringa che definisce il separatore delle migliaia;
      \item \textbf{tooltipFormat}: stringa che definisce il formato del tooltip;
      \item \textbf{stringPrefix}: stringa che definisce il prefisso del contatore;
      \item \textbf{stringSuffix}: stringa che definisce il suffisso del contatore;
      \item \textbf{formatTargetValue}: booleano che definisce se formattare o meno il valore target.
\end{itemize}

\subsection{DataLabels}
Interfaccia che definisce i tipi dei dati relativi alle label dei dati utilizzati negli \textit{heatmaps}.

\begin{minted}{typescript}
export interface DataLabels {
  x: any[];
  y: any[];
  mode: string;
  hoverinfo: string;
  showlegend: boolean;
  text: string[];
  textfont: {
    color: string[];
  };
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia DataLabels}
      \label{listing:dataLabels}
\end{listing}
\begin{itemize}
      \item \textbf{x}: array che definisce i valori sull'asse delle ascisse;
      \item \textbf{y}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{mode}: stringa che definisce la modalità;
      \item \textbf{hoverinfo}: stringa che definisce le informazioni del tooltip;
      \item \textbf{showlegend}: booleano che definisce se visualizzare o meno la legenda;
      \item \textbf{text}: array di stringhe che definisce il testo;
      \item \textbf{textfont}: oggetto che definisce le opzioni del font del testo:
            \begin{itemize}
                  \item \textbf{color}: array di stringhe che definisce i colori del font.
            \end{itemize}
\end{itemize}

\subsection{PlotlyOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione di Plotly.
\begin{minted}{typescript}
export interface PlotlyOptions {
  showLink: boolean;
  displaylogo: boolean;
  displayModeBar?: boolean;
  responsive?: boolean;
  autosize?: boolean;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia PlotlyOptions}
      \label{listing:plotlyOptions}
\end{listing}
\begin{itemize}
      \item \textbf{showLink}: booleano che definisce se visualizzare o meno il link;
      \item \textbf{displaylogo}: booleano che definisce se visualizzare o meno il logo;
      \item \textbf{displayModeBar}: booleano che definisce se visualizzare o meno la barra di Plotly;
      \item \textbf{responsive}: booleano che definisce se rendere o meno il grafico responsivo;
      \item \textbf{autosize}: booleano che definisce se adattare o meno la grandezza del grafico.
\end{itemize}

\subsection{RendererProps}
Interfaccia che definisce i tipi dei dati passati alla componenti \textit{Renderer, Counter, Chart} e \textit{Table}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface RendererProps {
            type: string;
            visualizationName: string;
            data: {
                  [x: string]: any;
            };
            options: VisualizationOptions;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia RendererProps}
      \label{listing:rendererProps}
\end{listing}
\begin{itemize}
      \item \textbf{type}: stringa che definisce il tipo componente da renderizzazre. Può assumere i seguenti valori: \textit{COUNTER}, \textit{CHART} e \textit{TABLE};
      \item \textbf{visualizationName}: stringa che definisce il titolo di visualizzazione della componente;
      \item \textbf{data}: oggetto che contiene i dati da visualizzare all'interno della componente;
      \item \textbf{options}: oggetto che contiene le opzioni di visualizzazione della componente di tipo \textit{VisualizationOptions}.
\end{itemize}

\subsection{Series}
Interfaccia che definisce i tipi dei dati relativi alle serie rappresentata nel grafico.
\begin{minted}{typescript}
export interface Series {
  name: string;
  type: string;
  data?: any[];
  visible?: boolean;
  values?: number[];
  labels?: string[];
  hole?: number;
  marker?: {
    colors?: string[];
    color?: string; 
    line?: {
      color?: string;
      width?: number;
    };
    size?: number;
    sizemode?: string;
  };
  hoverinfo?: string | boolean;
  text?: any[];
  textinfo?: string;
  textposition?: string;
  textangle?: number;
  textfont?: {
    size?: number;
    color?: string[];
  };
  direction?: string;
  domain?: {
    x: number[];
    y: number[];
  };
  sourceData?: Map<string, any>;
  hoverlabel?: {
    font?: {
      color?: string[];
    };
    bordercolor?: string;
    bgcolor?: string;
  };
  hover?: any[];
  x?: any;
  y?: any;
  z?: any;
  yaxis?: any;
  orientation?: number;
  insidetextfont?: {
    size?: number;
    color?: string;
  };
  error_y?: any;
  offsetgroup?: string;
  mode?: string;
  fill?: string;
  boxpoints?: string;
  jitter?: number;
  pointpos?: number;
  colorscale?: string | (string | number)[][];
  xgap?: number;
  ygap?: number;
}
\end{minted}
\begin{listing}[H]
      \caption{Definizione dell'interfaccia Series}
      \label{listing:series}
\end{listing}
\begin{itemize}
      \item \textbf{name}: stringa che definisce il nome della serie;
      \item \textbf{type}: stringa che definisce il tipo di serie;
      \item \textbf{data}: array che definisce i dati della serie;
      \item \textbf{visible}: booleano che definisce se la serie è visibile o meno;
      \item \textbf{values}: array di numeri che definisce i valori della serie;
      \item \textbf{labels}: array di stringhe che definisce le label della serie;
      \item \textbf{hole}: numero che definisce, nel caso di grafico a torta, il raggio del buco centrale;
      \item \textbf{marker}: oggetto che definisce le opzioni del marker;
      \item \textbf{hoverinfo}: stringa o booleano che definisce le informazioni del tooltip;
      \item \textbf{text}: array che definisce il testo della serie;
      \item \textbf{textinfo}: stringa che definisce le informazioni del testo;
      \item \textbf{textposition}: stringa che definisce la posizione del testo;
      \item \textbf{textangle}: numero che definisce l'angolo del testo;
      \item \textbf{textfont}: oggetto che definisce le opzioni del font del testo;
      \item \textbf{direction}: stringa che definisce la direzione della serie;
      \item \textbf{domain}: oggetto che definisce il dominio della serie;
      \item \textbf{sourceData}: mappa che definisce i dati sorgente;
      \item \textbf{hoverlabel}: oggetto che definisce le opzioni del tooltip;
      \item \textbf{hover}: array che definisce le opzioni del tooltip;
      \item \textbf{x}: array che definisce i valori sull'asse delle ascisse;
      \item \textbf{y}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{z}: array che definisce i valori sull'asse z;
      \item \textbf{yaxis}: array che definisce i valori sull'asse delle ordinate;
      \item \textbf{orientation}: numero che definisce l'orientamento;
      \item \textbf{insidetextfont}: oggetto che definisce le opzioni del font interno;
      \item \textbf{error\_y}: oggetto che definisce le opzioni degli errori sull'asse delle ordinate;
      \item \textbf{offsetgroup}: stringa che definisce il gruppo di offset;
      \item \textbf{mode}: stringa che definisce la modalità;
      \item \textbf{fill}: stringa che definisce il riempimento;
      \item \textbf{boxpoints}: stringa che definisce i punti del box;
      \item \textbf{jitter}: numero che definisce il jitter;
      \item \textbf{pointpos}: numero che definisce la posizione del punto;
      \item \textbf{colorscale}: stringa o array che definisce lo schema dei colori;
      \item \textbf{xgap}: numero che definisce il gap sull'asse delle ascisse;
      \item \textbf{ygap}: numero che definisce il gap sull'asse delle ordinate.
      \item \textbf{colors}: array di stringhe che definisce i colori del marker;
      \item \textbf{color}: stringa che definisce il colore del marker;
      \item \textbf{line}: oggetto che definisce le opzioni della linea del marker;
      \item \textbf{size}: numero che definisce la grandezza del marker;
      \item \textbf{sizemode}: stringa che definisce la modalità di dimensionamento del marker.
      \item \textbf{font}: oggetto che definisce le opzioni del font del marker;
      \item \textbf{bordercolor}: stringa che definisce il colore del bordo del marker;
      \item \textbf{bgcolor}: stringa che definisce il colore di sfondo del marker.
      \item \textbf{colors}: array di stringhe che definisce i colori delle rappresentazioni (multiple);
      \item \textbf{size}: numero che definisce la grandezza del font.
      \item \textbf{color}: stringa che definisce il colore della rappresentazione (singola).
\end{itemize}


\subsection{TableBaseVisualizationOptions}
Interfaccia che definisce i tipi dei dati relativi alle opzioni di visualizzazione del componente \textit{Table}.
\begin{listing}[H]
      \begin{minted}{typescript}
      export interface TableBaseVisualizationOptions {
            columns?: Column[];
            itemsPerPage?: number;
            paginationSize?: string;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia TableBaseVisualizationOptions}
      \label{listing:tableBaseVisualizationOptions}
\end{listing}
\begin{itemize}
      \item \textbf{columns}: array di oggetti che definiscono le colonne della tabella;
      \item \textbf{itemsPerPage}: numero che definisce il numero di elementi per pagina;
      \item \textbf{paginationSize}: stringa che definisce la grandezza della paginazione.
\end{itemize}

\subsection{VisualizationOptions}
Tipo che definisce le opzioni di visualizzazione delle componenti.
\begin{listing}[H]
      \begin{minted}{typescript}
      export type VisualizationOptions = 
            | CounterBaseVisualizationOptions 
            | ChartBaseVisualizationOptions 
            | TableBaseVisualizationOptions;
      \end{minted}
      \caption{Definizione del tipo VisualizationOptions}
      \label{listing:visualizationOptions}
\end{listing}
Questa definizione permette di definire le opzioni di visualizzazione specifiche per ciascun tipo di componente, garantendo una maggiore flessibilità
nella definizione di \textit{RendererProps}.

\subsection{VisualizationSettings}
Interfaccia che definisce i tipi dei dati relativi alle impostazioni di visualizzazione delle componenti.
\begin{listing}[H]
      \begin{minted}{typescript}
      interface VisualizationSettings {
            dateFormat: string;
            dateTimeFormat: string;
            integerFormat: string;
            floatFormat: string;
            booleanValues: string[];
            tableCellMaxJSONSize: number;
            allowCustomJSVisualizations: boolean;
            hidePlotlyModeBar: boolean;
            choroplethAvailableMaps: any;
      }
      \end{minted}
      \caption{Definizione dell'interfaccia VisualizationSettings}
      \label{listing:visualizationSettings}
\end{listing}
\begin{itemize}
      \item \textbf{dateFormat}: stringa che definisce il formato della data;
      \item \textbf{dateTimeFormat}: stringa che definisce il formato della data e dell'ora;
      \item \textbf{integerFormat}: stringa che definisce il formato degli interi;
      \item \textbf{floatFormat}: stringa che definisce il formato dei numeri decimali;
      \item \textbf{booleanValues}: array di stringhe che definisce i valori booleani;
      \item \textbf{tableCellMaxJSONSize}: numero che definisce la grandezza massima delle celle della tabella;
      \item \textbf{allowCustomJSVisualizations}: booleano che definisce se permettere o meno le visualizzazioni personalizzate;
      \item \textbf{hidePlotlyModeBar}: booleano che definisce se nascondere o meno la barra di Plotly;
      \item \textbf{choroplethAvailableMaps}: oggetto che definisce le mappe disponibili per il choropleth.
\end{itemize}

\subsection{VisualizationType}
Enumerazione che definisce i possibili valori dei tipi di visualizzazione supportati dalla libreria grafica.
\begin{listing}[H]
      \begin{minted}{typescript}
      export enum VisualizationType {
            Counter = 'COUNTER',
            Chart = 'CHART',
            Table = 'TABLE',
            None = 'NONE',
      }
      \end{minted}
      \caption{Definizione dell'enumerazione VisualizationType}
      \label{listing:visualizationType}
\end{listing}
I possibili valori dell'enumerazione sono i seguenti:
\begin{itemize}
      \item \textbf{Counter}: componente che visualizza un contatore;
      \item \textbf{Chart}: componente che visualizza un grafico;
      \item \textbf{Table}: componente che visualizza una tabella;
      \item \textbf{None}: valore di default, utilizzato per la gestione di errori o situazioni non previste.
\end{itemize}

\section{Progettazione delle componenti}
Nella seguente sezione verranno presentate le componenti individuate durante l'attività di progettazione, con una descrizione dettagliata delle
funzionalità offerte e delle possibili ottimizzazioni individuate. \newline
Le componenti verranno presentate in ordine alfabetico, presentando la seguente struttura:
\begin{itemize}
      \item \textbf{Nome della componente}: breve descrizione della componente;
      \item \textbf{Descrizione}: descrizione dettagliata delle funzionalità offerte dalla componente;
      \item \textbf{Props}: definizione delle props utilizzate dalla componente;
      \item \textbf{Ottimizzazioni}: possibili ottimizzazioni individuate per la componente.
\end{itemize}

\subsection{Counter}
\begin{itemize}
      \item \textbf{Nome della componente}: Counter;
      \item \textbf{Descrizione}: La componente Counter prevede la visualizzazione di un contatore, il cui valore viene definito a partire dai dati passati
            come props tra le varie componenti e forniti dalla risposta in formato JSON ricevuta dai server Datasoil. \newline
            La componente permette inoltre di confrontare il valore attuale del contatore con un valore target (opzionale) da raggiungere, anch'esso ricavato
            dalla risposta in formato JSON ricevuta dal server. \newline
            Il valore del contatore può essere formattato in base alle preferenze definite lato backend, presentando le seguenti opzioni:
            \begin{itemize}
                  \label{counter-format}
                  \item Prefisso: stringa da aggiungere prima del valore del contatore;
                  \item Suffisso: stringa da aggiungere dopo il valore del contatore;
                  \item Numero di cifre decimali: numero di cifre decimali da visualizzare nel valore del contatore;
                  \item Separatore delle migliaia: carattere da utilizzare come separatore delle migliaia;
                  \item Separatore decimale: carattere da utilizzare come separatore decimale.
            \end{itemize}
            (Queste formattazioni sono applicabili anche al valore target e ai tooltip visualizzati al passaggio del mouse sul contatore).\\
            L'implementazione delle formattazioni numeriche prevede l'utilizzo della libreria \textit{numbro.js}.
      \item \textbf{Props}: I props della componente Counter sono definiti dall'interfaccia \textit{RendererProps}, su cui il componente ne effettua il picking
            delle informazioni \textit{data, options} e \textit{visualizationName}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Counter({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
                  \caption{Definizione delle props della componente Counter}
                  \label{listing:counterProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo della libreria \textit{numbro.js} a favore della libreria \textit{numeral.js} precedentemente utilizzata, più pesante e non più mantenuta,
                        per la formattazione delle label numeriche all'interno del counter;
                  \item La progettazione della presente componente prevede l'utilizzo di hooks per la gestione del suo stato interno e per il calcolo delle dimensioni
                        del contatore, necessarie per permettere la visualizzazione responsiva della componente: l'utilizzo di tali hooks permette di garantire
                        un'implementazione efficiente e performante, riducendo il numero di renderizzazioni e computazioni non necessarie.
            \end{itemize}

\end{itemize}

\subsection{Chart}
\begin{itemize}
      \item \textbf{Nome della componente}: Chart;
      \item \textbf{Descrizione}: La componente Chart prevede la visualizzazione di un grafico, il cui tipo e i dati da visualizzare vengono definiti a partire dai dati passati
            come props tra le varie componenti e forniti dalla risposta in formato JSON ricevuta dai server Datasoil. \newline
            I tipi di grafici che tale componente permette di renderizzare sono i seguenti:
            \begin{itemize}
                  \item Area Chart: grafico ad area;
                  \item Bar Chart: grafico a barre;
                  \item Box Plot Chart: grafico a scatola;
                  \item Bubble Chart: grafico a bolle;
                  \item HeatMap Chart: grafico a matrice;
                  \item Line Chart: grafico a linee;
                  \item Pie Chart: grafico a torta;
                  \item Scatter Chart: grafico a dispersione.
            \end{itemize}
            La componente permette inoltre, a seconda del tipo di grafico renderizzato, di:
            \begin{itemize}
                  \item Effettuare il download dell'immagine del grafico in formato \textit{.png};
                  \item Effettuare lo zoom sul grafico;
                  \item Effettuare lo zoom-in sul grafico;
                  \item Effettuare lo zoom-out sul grafico;
                  \item Effettuare il pan sul grafico;
                  \item Effettuare l'autoscale sul grafico;
                  \item Resettare la dimensione degli assi del grafico.
            \end{itemize}
            A fronte di tali funzionalità, l'implementazione della componente prevede l'utilizzo della libreria \textit{Plotly.js}, la quale permette
            di renderizzare grafici in modo reattivo. \newline
            Le evenutali label applicate ai grafici possono essere formattate in base alle preferenze definite lato backend, presentando le seguenti opzioni. \newline
            Label numeriche:
            \begin{itemize}
                  \item Numero di cifre decimali: numero di cifre decimali da visualizzare nel valore della label;
                  \item Separatore delle migliaia: carattere da utilizzare come separatore delle migliaia;
                  \item Separatore decimale: carattere da utilizzare come separatore decimale;
                  \item suffessi: stringa da aggiungere dopo il valore della label, ad esempio \textit{\%}.
            \end{itemize}
            L'implementazione delle formattazioni numeriche prevede l'utilizzo della libreria \textit{numbro.js}. \newline
            Label temporali:
            \begin{itemize}
                  \item Formato della data: formato da utilizzare per la visualizzazione della data;
                  \item Formato dell'ora: formato da utilizzare per la visualizzazione dell'ora.
            \end{itemize}
            L'implementazione delle formattazioni temporali prevede l'utilizzo della liberia \textit{day.js}.
      \item \textbf{Props}: I props della componente Chart sono definiti dall'interfaccia \textit{RendererProps}, su cui il componente ne effettua il picking
            delle informazioni \textit{data} e \textit{options}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Chart({
                        data,
                        options,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options'>);
                  \end{minted}
                  \caption{Definizione delle props della componente Chart}
                  \label{listing:chartProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo di un custom-bundle di \textit{Plotly.js} in modo da ridurre le dimensioni del bundle finale, evitando la registrazione
                        di grafici non utilizzati all'interno delle dashboard Datasoil S.r.l. Tale ottimizzazione permette inoltre di evitare la registrazione
                        manuale delle \textit{traces}, necessaria nelle versioni rese disponibili da \textit{Plotly.js} a causa di un bug noto non risolto della libreria.
                  \item Utilizzo della libreria \textit{numbro.js} a favore della libreria \textit{numeral.js} precedentemente utilizzata, più pesante e non più mantenuta,
                        per la formattazione delle label numeriche all'interno dei grafici;
                  \item Utilizzo della libreria \textit{day.js} a favore della libreria \textit{moment.js} precedentemente utilizzata, in quanto questa libreria costituisce una
                        peerdependency di \textit{dashboard}, riducendo così le dimensioni del bundle finale;
                  \item Utilizzo di un custom hooks per la gestione dello stato interno della componente e per il calcolo delle dimensioni del grafico, necessarie per permettere
                        la visualizzazione responsiva della componente. L'utilizzo dell'hooks è volto a garantire un'implementazione efficiente e performante della componente.
            \end{itemize}
\end{itemize}

\subsection{Table}
\begin{itemize}
      \item \textbf{Nome della componente}: Table;
      \item \textbf{Descrizione}: La componente Table prevede la visualizzazione di una tabella, i cui dati e la cui struttura (intesa come colonne e tipo di dato visualizzato
            all'interno di esse) vengono definiti a partire dai dati passati come props tra le varie componenti e forniti dalla risposta in formato JSON ricevuta dai server Datasoil. \newline
            La componente permette inoltre di:
            \begin{itemize}
                  \item Ordinare le colonne della tabella;
                  \item Filtrare le entry della tabella grazie ad un filtro globale;
                  \item Effettuare il download della tabella in formato \textit{.csv};
            \end{itemize}
            A fronte di tali funzionalità, l'implementazione della componente prevede l'utilizzo della componente fornita dalla libreria \textit{PrimeReact}.
      \item \textbf{Props}: I props della componente Table sono definiti dall'interfaccia \textit{RendererProps}, su cui il componente ne effettua il picking
            delle informazioni \textit{data, options} e \textit{visualizationName}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  export function Table({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
                  \caption{Definizione delle props della componente Table}
                  \label{listing:tableProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Utilizzo della componente \textit{DataTable} fornita dalla libreria \textit{PrimeReact} a favore della componente \textit{Table} di \textit{AntD} precedentemente utilizzata,
                        in quanto la libreria \textit{PrimeReact} offre una maggiore flessibilità e personalizzazione delle tabelle, oltre che a costituire una peerdependency all'interno dei
                        prodotti Datasoil S.r.l., riducendo così le dimensioni del bundle finale;
                  \item Utilizzo di hook per la gestione del filtro globale, in modo da garantire un'implementazione efficiente e performante della componente, a differenza dell'implementazione
                        fornita da \textit{PrimeReact} che comporta un bug noto non risolto. \label{item:hookTable}
            \end{itemize}
\end{itemize}

\subsection{Renderer}
\begin{itemize}
\item \textbf{Nome della componente}: Renderer;
\item \textbf{Descrizione}: La componente Renderer seleziona dinamicamente un sottocomponente tra quelli resi disponibili dalla libreria \textit{viz-lib}
in base al tipo di visualizzazione definito nei dati passati come props, costituendo l'entry point della libreria. \newline
\item \textbf{Props}: I props della componente Renderer sono definiti dall'interfaccia \textit{RendererProps}, su cui il componente ne effettua il picking
delle informazioni \textit{data, options} e \textit{visualizationName}.
\begin{listing}[H]
      \begin{minted}{typescript}
                  export function Renderer({
                        data,
                        options,
                        visualizationName,
                        }: Pick<RendererProps, 
                              'data' 
                              | 'options' 
                              | 'visualizationName'>);
                  \end{minted}
      \caption{Definizione delle props della componente Renderer}
      \label{listing:rendererPropsInComponent}
\end{listing}
\item \textbf{Ottimizzazioni}:
\begin{itemize}
      \item La componente prevede l'utilizzo di \textit{hooks} per ottimizzare le prestazioni, rendendo il componente memoizzato, prevenendo i rendering
            non necessari, garantendo così un'implementazione efficiente e performante.
\end{itemize}

\subsection{VisualizationWidgetHeader}
\begin{itemize}
      \item \textbf{Nome della componente}: VisualizationWidgetHeader;
      \item \textbf{Descrizione}: La componente VisualizationWidgetHeader appartiene alla libreria \textit{dashboard}, appartenente sempre al SDK prodotto. Questa componente costituisce l'header
            del container per la visualizzazione delle componenti da renderizzare all'interno della dashboard. \newline
      \item \textbf{Props}: I props della componente VisualizationWidgetHeader sono definiti delle informazioni \textit{name, visualization} e \textit{dataDialog}.
            \begin{listing}[H]
                  \begin{minted}{typescript}
                  function VisualizationWidgetHeader({
                        name,
                        visualization,
                        dataDialog,
                        }: {
                        name: string;
                        visualization: Visualization;
                        dataDialog: WidgetData | undefined;
                        });
                  \end{minted}
                  \caption{Definizione delle props della componente VisualizationWidgetHeader}
                  \label{listing:visualizationWidgetHeaderProps}
            \end{listing}
      \item \textbf{Ottimizzazioni}:
            \begin{itemize}
                  \item Ridefinizione dei props della componente in modo da permettere la visualizzazione di un dialog contenente la componente visualizzata all'interno del container;
                  \item Ridefinizione della componente in modo da permettere la visualizzazione di un dialog contenente la componente visualizzata all'interno del container, attraverso
                        l'utilizzo di componenti fornite dalla libreria \textit{PrimeReact}.
            \end{itemize}
\end{itemize}