\chapter{Realizzazione e testing}
\label{chap:realizzazione-testing}
Nella seguente sezione verranno presentate le attività di realizzazione e testing effettuate durante lo sviluppo della libreria, con l'obiettivo di fornire una panoramica
sulle tecnologie utilizzate, sulle funzionalità implementate e sui test effettuati per garantire la qualità del prodotto sviluppato.

\section{Strumenti utilizzati}
La seguente sezione fornisce gli strumenti utilizzati durante lo svolgimento dello stage per la realizzazione della libreria grafica.
Gli strumenti verranno presentati in ordine alfabetico secondo la seguente struttura:
\begin{itemize}
    \item \textbf{Nome strumento}: nome dello strumento utilizzato;
    \item \textbf{Versione}: versione utilizzata nel progetto durante lo stage;
    \item \textbf{Link}: link di riferimento per ulteriori informazioni sullo strumento;
    \item \textbf{Descrizione}: breve descrizione dello strumento e delle sue funzionalità;
    \item \textbf{Vantaggi}: principali vantaggi derivanti dall'utilizzo dello strumento; \textit{(Opzionale)}
    \item \textbf{Svantaggi}: principali svantaggi derivanti dall'utilizzo dello strumento; \textit{(Opzionale)}
    \item \textbf{Alternative Esaminate}: alternative studiate e prese in considerazione durante la scelta dello strumento, con una breve considerazione
          su di esse e la motivazione per la quale non sono state selezionate. \textit{(Opzionale)}
\end{itemize}

\subsection{Tecnologie frontend}

\subsubsection{D3-color}
\begin{itemize}
    \item \textbf{Nome strumento}: D3-color
    \item \textbf{Versione}: 3.1.0
    \item \textbf{Link}: \href{https://d3js.org/d3-color}{d3js.org/d3-color}
    \item \textbf{Descrizione}: D3-color è una libreria JavaScript open-source utilizzata per la manipolazione dei colori.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{D3-color} offre un'ampia serie di funzionalità per la manipolazione dei colori, quali la conversione tra spazi di colori, la manipolazione dei colori
                    e la generazione di scale di colori;
              \item \textit{D3-color} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
    \item \textit{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{Chroma-js}: \textit{Chroma-js} è una libreria \textit{JavaScript} \textit{open-source} utilizzata per la manipolazione dei colori, ma risulta essere più pesante di \textit{D3-color}.
          \end{itemize}
\end{itemize}

\subsubsection{D3-scale}
\begin{itemize}
    \item \textbf{Nome strumento}: D3-scale
    \item \textbf{Versione}: 4.0.2
    \item \textbf{Link}: \href{https://d3js.org/d3-scale}{d3js.org/d3-scale}
    \item \textbf{Descrizione}: \textit{D3-scale} è una libreria \textit{JavaScript} open-source utilizzata per la generazione di scale di colori, di posizioni e di dimensioni.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{D3-scale} offre un'ampia serie di funzionalità per la generazione di scale di colori, di posizioni e di dimensioni, quali la generazione di scale lineari,
                    logaritmiche e ordinali;
              \item \textit{D3-scale} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
\end{itemize}

\subsubsection{Day.js}
\begin{itemize}
    \item \textbf{Nome strumento}: Dayjs
    \item \textbf{Versione}: 1.11.7
    \item \textbf{Link}: \href{https://day.js.org/}{day.js.org}
    \item \textbf{Descrizione}: \textit{Day.js} è una libreria \textit{JavaScript} open-source utilizzata per la manipolazione delle date e degli orari.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Day.js} è una libreria molto leggera, con un'ampia serie di funzionalità per la manipolazione delle date e degli orari;
              \item \textit{Day.js} viene fornito con dichiarazioni ufficiali di tipo per \textit{TypeScript};
              \item \textit{Day.js} è tutt'ora supportato da una vasta e attiva \textit{community}.
          \end{itemize}
    \item \textbf{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{Moment.js}: \textit{Moment.js} è una libreria \textit{JavaScript} open-source utilizzata per la manipolazione delle date e degli orari, ma risulta essere più pesante
                    di \textit{Day.js}. \textit{Moment.js} è inoltre considerato \textit{deprecated} a favore di Day.js, che offre una maggiore leggerezza e una maggiore efficienza.
          \end{itemize}
\end{itemize}

\subsubsection{Lodash}
\begin{itemize}
    \item \textbf{Nome strumento}: Lodash
    \item \textbf{Versione}: 4.14.0
    \item \textbf{Link}: \href{https://lodash.com/}{lodash.com}
    \item \textbf{Descrizione}: \textit{Lodash} è una libreria \textit{JavaScript} \textit{open-source} utilizzata per la manipolazione di oggetti e array.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Lodash} offre un'ampia serie di funzionalità implementate con efficienza per la manipolazione di oggetti e array,
                    quali la ricerca, la modifica e la rimozione di elementi;
              \item \textit{Lodash} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
    \item \textbf{Svantaggi}
          \begin{itemize}
              \item \textit{Lodash} è una libreria molto pesante, con un'ampia serie di funzionalità che possono non essere utilizzate all'interno del progetto:
                    per questo motivo in questo progetto sono eseguiti degli \texttt{import} sui moduli specifici, riducendo così le dimensioni del \textit{\gls{package}\glox} finale.
          \end{itemize}
\end{itemize}

\subsubsection{Numbro}
\begin{itemize}
    \item \textbf{Nome strumento}: Numbro
    \item \textbf{Versione}: 2.5.0
    \item \textbf{Link}: \href{http://numbrojs.com/}{numbrojs.com}
    \item \textbf{Descrizione}: \textit{Numbro} è una libreria \textit{JavaScript} open-source utilizzata per la formattazione dei numeri.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Numbro} offre un'ampia serie di funzionalità per la formattazione dei numeri, quali la formattazione delle cifre decimali, la formattazione delle valute
                    e la formattazione dei numeri in notazione scientifica;
              \item \textit{Numbro} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
    \item \textbf{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{Numeral.js}: libreria \textit{JavaScript} open-source utilizzata per la formattazione dei numeri, ma risulta non essere più mantenuta attivamente dalla \textit{community}, oltre
                    che ad essere più pesante di \textit{Numbro}.
          \end{itemize}
\end{itemize}

\subsubsection{Plotly.js}
\begin{itemize}
    \item \textbf{Nome strumento}: Plotly.js
    \item \textbf{Versione}: custom-bundle: 2.33.0
    \item \textbf{Link}: \href{https://plotly.com/javascript/}{plotly.com/javascript}
    \item \textbf{Descrizione}: \textit{Plotly.js} è una libreria \textit{JavaScript open-source}, con supporto per \textit{TypeScript}, utilizzata per la visualizzazione di dati mediante grafici interattivi.
          Costruito sopra \textit{D3.js}, \textit{Plotly.js} offre un vasto panorama di grafici dinamici in formato \textit{\gls{SVG}\glox}, altamente personalizzabili.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Plotly.js} offre funzionalità di interattività avanzate, quali zoom, pan, selezione e salvataggio dei grafici;
              \item Le disponibilità di grafici offerte da \textit{Plotly.js} sono molto ampie, permettendo di soddisfare la maggior parte delle esigenze
                    all'interno della libreria grafica;
              \item \textit{Plotly.js} è supportato da una vasta e attiva \textit{community}, con ampie serie di esempi disponibili su \textit{CodePen} (\href{https://codepen.io/}{codepen.io}, una piattaforma di condivisione di codice
                    \textit{online} che permette di visualizzare e modificare codice \textit{HTML, CSS e JavaScript});
              \item \textit{Plotly.js} offre la possibilità di generare \textit{custom bundle} personalizzati, permettendo di registrare le sole \textit{traces} che si vogliono utilizzare, riducendo
                    così le dimensioni del pacchetto finale;
              \item \textit{Plotly.js} era già precedentemente utilizzato all'interno della libreria preesistente, non necessitando così di modifiche lato \textit{\gls{backend}\glox} negli editor
                    utilizzati per la generazione delle risposte \textit{JSON} da parte dei server \textit{Datasoil S.r.l.} per la generazione delle dashboard;
              \item \textit{Plotly.js} offre una funzionalità, \textit{Plotly.react}, che permette di aggiornare i grafici in modo efficiente, riducendo il tempo di rendering
                    e migliorando le prestazioni complessive della libreria.
          \end{itemize}
    \item \textbf{Svantaggi}:
          \begin{itemize}
              \item \textit{Plotly.js} è una libreria molto pesante in termini sia di spazio che di rallentamenti \textit{\gls{runtime}\glox}, dovuto anche dal fatto che è implementata sopra un \textit{wrapper} proprietario di \textit{D3.js},
                    impedendo l'ottimizzazione di alcune dipendenze non necessarie in quanto non utilizzate;
              \item La documentazione ufficiale di \textit{Plotly.js} è vaga e poco esaustiva;
              \item La versione ufficiale di \textit{Plotly.js} presenta degli errori durante la registrazione delle \textit{traces}, impedendo di importare correttamente
                    \textit{Plotly} all'interno dei moduli \textit{TypeScript}, motivo per il quale è stata utilizzata una versione \textit{custom bundle} di \textit{Plotly.js}.
          \end{itemize}
    \item \textbf{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{D3.js}: \textit{D3.js} è una libreria \textit{JavaScript open-source} utilizzata per la generazione di grafici dinamici e manipolazione dati, la quale dalla sua parte risulta però
                    essere più complessa rispetto a \textit{Plotly.js}, richiedendo una maggiore curva di apprendimento e una maggiore quantità di codice per la generazione di grafici.
              \item \textit{Chart.js}: \textit{Chart.js} è una libreria \textit{JavaScript open-source} utilizzata per la generazione di grafici dinamici, la quale risulta essere più leggera di \textit{Plotly.js},
                    ma offre una minore quantità di grafici disponibili; il suo utilizzo avrebbe inoltre comportato la richiesta di modifiche lato \textit{backend}.
          \end{itemize}
\end{itemize}

\subsubsection{PrimeFlex}
\begin{itemize}
    \item \textbf{Nome strumento}: PrimeFlex
    \item \textbf{Versione}: 3.3.0
    \item \textbf{Link}: \href{https://primereact.org/}{primefaces.org/primeflex}
    \item \textbf{Descrizione}: \textit{PrimeFlex} è una libreria \textit{CSS open-source} utilizzata per la creazione di \textit{layout} flessibili e \textit{\gls{responsive}\glox}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{PrimeFlex} offre un'ampia serie di classi \textit{CSS} per la creazione di \textit{layout} flessibili e responsivi, permettendo di adattare il \textit{layout}
                    in base alla grandezza dello schermo;
              \item \textit{PrimeFlex} è una libreria molto leggera;
              \item \textit{PrimeFlex} è fortemente integrata con le componenti di \textit{PrimeReact};
              \item \textit{PrimeFlex} può essere integrato a \textit{tailwind};
              \item \textit{PrimeFlex} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
\end{itemize}

\subsubsection{PrimeIcons}
\begin{itemize}
    \item \textbf{Nome strumento}: PrimeIcons
    \item \textbf{Versione}: 6.0.1
    \item \textbf{Link}: \href{https://primefaces.org/primeicons}{primefaces.org/primeicons}
    \item \textbf{Descrizione}: \textit{PrimeIcons} è una libreria di icone \textit{open-source} utilizzata per la creazione di interfacce utente.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{PrimeIcons} offre un'ampia serie di icone per la creazione di interfacce utente, le quali sono altamente personalizzabili e facilmente integrabili;
              \item \textit{PrimeIcons} è una libreria molto leggera, permettendo di creare interfacce utente performanti e veloci;
              \item \textit{PrimeIcons} è fortemente integrata con le componenti di \textit{PrimeReact};
              \item \textit{PrimeIcons} è supportato da una vasta e attiva community.
          \end{itemize}
\end{itemize}

\subsubsection{PrimeReact}
\begin{itemize}
    \item \textbf{Nome strumento}: PrimeReact
    \item \textbf{Versione}: 10.0.0
    \item \textbf{Link}: \href{https://primefaces.org/primereact}{primefaces.org/primereact}
    \item \textbf{Descrizione}: \textit{PrimeReact} è una libreria di componenti \textit{React open-source} utilizzata per la creazione di interfacce utente.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{PrimeReact} offre un'ampia serie di componenti \textit{React} per la creazione di interfacce utente, le quali a loro volta sono altamente personalizzabili, con numerose \textit{feature} integrate;
              \item \textit{PrimeReact} è una libreria molto leggera, permettendo di creare interfacce utente performanti e veloci;
              \item \textit{PrimeReact} costituisce una \textit{\gls{peerdependency}\glox} all'interno dei prodotti \textit{Datasoil S.r.l.}, permettendo di utilizzare le componenti \textit{PrimeReact} all'interno
                    della libreria grafica senza comportare l'aggiunta di dipendenze esterne, riducendo così le dimensioni del \textit{bundle} finale;
              \item \textit{PrimeReact} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
    \item \textbf{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{Ant Design}: \textit{Ant Design} è una libreria di componenti \textit{React open-source} utilizzata per la creazione di interfacce utente, la quale non risulta però
                    essere integrata all'interno dei prodotti \textit{Datasoil S.r.l.}
          \end{itemize}
\end{itemize}


\subsubsection{React}
\begin{itemize}
    \item \textbf{Nome strumento}: React
    \item \textbf{Versione}: 18.0.0
    \item \textbf{Link}: \href{https://reactjs.org/}{reactjs.org}
    \item \textbf{Descrizione}: \textit{React} è una libreria \textit{React open-source} per la creazione di interfacce utente, sviluppata da Facebook.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{React} offre un'ampia serie di funzionalità per la creazione di interfacce utente, quali il \textit{Virtual DOM}, il \textit{JSX} e \textit{Hooks};
              \item \textit{React} è supportato da una vasta e attiva \textit{community};
              \item \textit{React} è una libreria molto leggera, permettendo di creare interfacce utente performanti e veloci.
          \end{itemize}
\end{itemize}

\subsubsection{TypeScript}
\begin{itemize}
    \item \textbf{Nome strumento}: TypeScript
    \item \textbf{Versione}: 5.1.6
    \item \textbf{Link}: \href{https://www.typescriptlang.org/}{typescriptlang.org}
    \item \textbf{Descrizione}: \textit{TypeScript} è un linguaggio di programmazione open-source sviluppato da \textit{Microsoft}, che fa da \textit{\gls{super-set}\glox} a \textit{JavaScript}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{TypeScript} permette di definire tipi ed interfacce per le variabili e i parametri delle funzioni, garantendo una maggiore sicurezza e affidabilità del codice;
              \item \textit{TypeScript} permette di effettuare controlli statici sul codice sorgente, riducendo il numero di errori a \textit{runtime}.
          \end{itemize}
\end{itemize}

\subsubsection{usehook-ts}
\begin{itemize}
    \item \textbf{Nome strumento}: usehook-ts
    \item \textbf{Versione}: 3.1.0
    \item \textbf{Link}: \href{https://usehooks-ts.com/}{usehooks-ts.com}
    \item \textbf{Descrizione}: \textit{usehook-ts} è una libreria \textit{open-source} di \textit{custom hook React}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{usehook-ts} offre un'ampia serie di \textit{hook} personalizzati per la creazione di interfacce utente;
              \item \textit{usehook-ts} è supportato da una vasta e attiva \textit{community}.
          \end{itemize}
\end{itemize}

\subsection{Strumenti per lo sviluppo}

\subsubsection{ESLint}
\begin{itemize}
    \item \textbf{Nome strumento}: ESLint
    \item \textbf{Versione}: 8.3.0
    \item \textbf{Link}: \href{https://eslint.org/}{eslint.org}
    \item \textbf{Descrizione}: \textit{ESLint} è uno strumento \textit{open-source} utilizzato per l'analisi statica del codice sorgente, per identificare pattern problematici o codice che non rispetta
          le linee guida definite all'interno del progetto.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{ESLint} permette di definire regole personalizzate per l'analisi del codice sorgente, garantendo la coerenza e la qualità del codice;
              \item \textit{ESLint} permette di integrarsi con gli strumenti di \textit{build}, permettendo di eseguire l'analisi statica del codice sorgente durante il processo di \textit{build}.
          \end{itemize}
\end{itemize}

\subsubsection{Jest}
\begin{itemize}
    \item \textbf{Nome strumento}: Jest
    \item \textbf{Versione}: 29.0.7
    \item \textbf{Link}: \href{https://jestjs.io/}{jestjs.io}
    \item \textbf{Descrizione}: \textit{Jest} è un \textit{framework} di testing \textit{open-source} utilizzato per il testing di codice \textit{JavaScript} e \textit{TypeScript}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Jest} permette di effettuare test unitari, test di integrazione e test \textit{end-to-end}, garantendo la qualità e la stabilità del codice;
              \item \textit{Jest} permette di effettuare test in parallelo, riducendo i tempi di esecuzione dei test;
              \item \textit{Jest} permette di generare report dettagliati sui test effettuati, permettendo di identificare e correggere eventuali errori.
          \end{itemize}
\end{itemize}


\subsubsection{NVM}
\begin{itemize}
    \item \textbf{Nome strumento}: NVM
    \item \textbf{Versione}: 1.1.12
    \item \textbf{Link}: \href{https://github.com/nvm-sh/nvm}{github.com/nvm-sh/nvm}
    \item \textbf{Descrizione}: \textit{NVM (Node Version Manager)} è uno strumento \textit{open-source} utilizzato per la gestione delle versioni di \textit{Node.js}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{NVM} permette di installare e gestire più versioni di \textit{Node.js} all'interno del sistema, permettendo di selezionare la versione corretta
                    per il progetto in corso;
              \item \textit{NVM} permette di gestire le versioni di \textit{Node.js} in modo semplice e veloce, permettendo di passare da una versione all'altra con un solo comando.
          \end{itemize}
\end{itemize}

\subsubsection{Prettier}
\begin{itemize}
    \item \textbf{Nome strumento}: Prettier
    \item \textbf{Versione}: 3.2.5
    \item \textbf{Link}: \href{https://prettier.io/}{prettier.io}
    \item \textbf{Descrizione}: \textit{Prettier} è uno strumento \textit{open-source} utilizzato per la formattazione del codice sorgente.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Prettier} permette di formattare il codice sorgente in modo automatico, garantendo uno stile uniforme all'interno del progetto.
          \end{itemize}
\end{itemize}

\subsubsection{Rollup}
\begin{itemize}
    \item \textbf{Nome strumento}: Rollup
    \item \textbf{Versione}: 4.18.0
    \item \textbf{Link}: \href{https://rollupjs.org/}{rollupjs.org}
    \item \textbf{Descrizione}: \textit{Rollup} è un \textit{\gls{bundler}\glox} di moduli \textit{JavaScript} che permette di risolvere le dipendenze tra i moduli, generando un unico file di output.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Rollup} effettua il \textit{\gls{tree-shaking}\glox}, rimuovendo le dipendenze non utilizzate all'interno del codice sorgente;
              \item Permette di generare bundle in diversi formati, quali \textit{CommonJS} e \textit{ESM};
              \item \textit{Rollup} è noto per la sua velocità ed efficienza nelle \textit{build}, specialmente per progetti più piccoli o librerie.
                    Questo può risultare in tempi di \textit{build} più rapidi e in una migliore esperienza di sviluppo;
              \item \textit{Rollup} ha un sistema di \textit{plug-in} molto potente e flessibile che permette di estendere le sue funzionalità;
              \item \textit{Rollup} permette di utilizzare \textit{TypeScript} all'interno del progetto, integrando la configurazione dichiarata nel file \textit{tsconfig.json};
              \item \textit{Rollup} permette di generare file di dichiarazione \textit{TypeScript}.
          \end{itemize}
\end{itemize}

\subsubsection{Yarn}
\begin{itemize}
    \item \textbf{Nome strumento}: Yarn
    \item \textbf{Versione}: 1.22.22
    \item \textbf{Link}: \href{https://yarnpkg.com/}{yarnpkg.com}
    \item \textbf{Descrizione}: \textit{Yarn} è un \textit{package manager} per \textit{JavaScript}, sviluppato da \textit{Facebook, Google} e \textit{Tilde}.
    \item \textbf{Vantaggi}:
          \begin{itemize}
              \item \textit{Yarn} è più veloce di \textit{npm}, ha un sistema di cache più efficiente e permette di installare pacchetti in parallelo.
          \end{itemize}
    \item \textbf{Svantaggi}:
          \begin{itemize}
              \item \textit{Yarn} presenta un \textit{registry} di dimensione minore rispetto a quello di \textit{npm}.
          \end{itemize}
    \item \textbf{Alternative Esaminate}:
          \begin{itemize}
              \item \textit{npm}: npm è il \textit{package manager} di default per \textit{Node.js}, ma è più lento di \textit{Yarn} e ha un sistema di cache meno efficiente,
                    offrendo inoltre un output meno comprensibile.
          \end{itemize}
\end{itemize}

\subsection{Strumenti per la Collaborazione e la Gestione del Progetto}
Nella seguente sezione vengono presentati gli strumenti utilizzati per la collaborazione e la gestione del progetto durante lo svolgimento dello stage.

\subsubsection{Confluence}
\begin{itemize}
    \item \textbf{Nome strumento}: Confluence
    \item \textbf{Versione}: Cloud
    \item \textbf{Link}: \href{https://www.atlassian.com/software/confluence}{atlassian.com/software/confluence}
    \item \textbf{Descrizione}: \textit{Confluence} è un software di collaborazione sviluppato da \textit{Atlassian}, utilizzato per la creazione e la gestione della documentazione
          all'interno di un'azienda.
\end{itemize}

\subsubsection{Slack}
\begin{itemize}
    \item \textbf{Nome strumento}: Slack
    \item \textbf{Versione}: Cloud
    \item \textbf{Link}: \href{https://slack.com/}{slack.com}
    \item \textbf{Descrizione}: \textit{Slack} è un software di collaborazione sviluppato da \textit{Slack Technologies}, utilizzato per la comunicazione quotidiana e la collaborazione
          con il team.
\end{itemize}

\section{Realizzazione delle componenti}

\subsection{Ambiente di sviluppo}
Durante lo sviluppo della libreria, è stata utilizzata la versione 18.12.1 di \textit{Node.js}, configurata tramite l'utilizzo di \textit{NVM (Node Version Manager)},
un gestore di versioni di \textit{Node.js} che permette di installare e gestire più versioni in modo semplice e veloce. \newline
Per quanto riguarda la gestione delle dipendenze, è stato utilizzato \textit{Yarn}, un \textit{package manager} per \textit{JavaScript} che permette di gestire
le dipendenze del progetto in modo efficiente e veloce. \newline
Il versionamento del codice è stato gestito tramite \textit{Git}, un sistema di controllo di versione distribuito, configurando e
mantenendo un \textit{\gls{repository}\glox} remoto su \textit{Github} interno all'organizzazione dell'azienda. \newline
All'interno del file \textit{package.json} è stata configurata la sezione \textit{scripts} per definire i comandi necessari per l'esecuzione:
\begin{itemize}
    \item \texttt{start-watcher}: avvia il processo di building del codice di \texttt{rollup} in modalità \textit{watch}, in modo da monitorare le modifiche effettuate
          ai file sorgenti e aggiornare automaticamente il bundle prodotto e utilizzato dall'example all'interno del progetto;
    \item \texttt{start-example}: avvia l'esecuztone dell'esempio all'interno del progetto nel server locale, permettendo di visualizzare il funzionamento della libreria
          all'interno di un'applicazione di test;
    \item \texttt{build-package}: avvia il procetso di building del codice di \textit{rollup}, generando i bundle finali configurati all'interno del file \textit{rollup.config.js};
    \item \texttt{publish-package}: avvia il protesso di pubblicazione del pacchetto all'interno del registry privato configurato nel \textit{package.json} dei \textit{packages}, permettendo
          di distribuire la libreria all'interno dell'organizzazione;
    \item \texttt{test}: avvia il processo di tetting del codice tramite \textit{Jest}, effettuando i test definiti all'interno della \textit{repository}.
\end{itemize}
\begin{listing}[H]
    \begin{minted}{json}
    "scripts": {
        "start-example": "cd packages/example && yarn start",
        "start-watcher": "cd packages/dsdashboard2 && yarn rollup-watch",
        "build-package": "cd packages/dsdashboard2 && yarn build",
        "publish-package": "cd packages/dsdashboard2 && yarn publish"
    }
    \end{minted}
    \caption{Scripts del file \textit{package.json} di \textit{dsdashboard2}}
    \label{listing:scripts_package_json_dsdashboard2}
\end{listing}

\begin{listing}[H]
    \begin{minted}{json}
    "scripts": {
        "rollup": "rollup -c --bundleConfigAsCjs",
        "rollup-watch": "rollup -c --bundleConfigAsCjs --watch",
        "clean": "rimraf dist",
        "build": "yarn clean && yarn rollup",
        "test": "jest"
    }
    \end{minted}
    \caption{Scripts del file \textit{package.json} dei \textit{packages}}
    \label{listing:scripts_package_json_packages}
\end{listing}
Tutti i precedenti comandi vengono eseguiti tramite il comando \textit{yarn} seguito dal nome dello script definito all'interno del file \textit{package.json}.

\subsection{Componenti}
Nella presente sezione viene descritta l'implementazione delle componenti e delle loro ottimizzazioni all'interno della libreria,
con l'obiettivo di fornire una panoramica sulle funzionalità offerte, sulle tecnologie utilizzate e sul flusso di dati all'interno del sistema.

\subsubsection{Counter}
La componente \texttt{Counter} costituisce un contatore che permette di visualizzare un valore numerico all'interno di un \textit{widget}, associato a un'etichetta
rappresentativa dell'informazione visualizzata. \\
La componente permette inoltre di visualizzare un target, il valore di riferimento da raggiungere, mettendo a disposizione la componente grafica \texttt{Knob}
della libreria \textit{PrimeReact}, definendo colori differenti per il valore visualizzato a seconda del raggiungimento o meno del target. \\
La componente offre inoltre la possibilità di visualizzare dei \textit{tooltip}, fornendo informazioni più dettagliate all'utente
in merito ai dati visualizzati, attraverso l'utilizzo dell'attributo \texttt{title} associati ai \texttt{div} contenenti i valori visualizzati. \\
Le informazioni utilizzate dalla componente vengono elaborate dalla funzione \\
\texttt{getCounterData}, chiamata all'interno dell'\texttt{hook useMemo}, in modo da
effettuare il ricalcolo dei dati solo in caso di variazione delle \textit{props} passate alla componente. Questa funzione infatti, a partire dai \texttt{data}, dalle \texttt{optionsCounter}
(opzioni di visualizzazione ottenute attraverso la concatenazazione delle opzioni di default e le \textit{options} passate come \textit{props} al componente) e dal \texttt{visualizationName}
permette di definite i seguenti valori:
\begin{itemize}
    \item \textit{CounterValue}: valore numerico del contatore;
    \item \textit{TargetValue}: valore di riferimento da raggiungere;
    \item \textit{CounterLabel}: etichetta associata al valore numerico;
    \item \textit{CounterValueTooltip}: testo del \textit{tooltip} associato al valore del contatore;
    \item \textit{TargetValueTooltip}: testo del \textit{tooltip} associato al valore di riferimento;
    \item \textit{TrendPositive}: valore booleano che indica se il valore del contatore ha raggiunto o superato il valore target;
    \item \textit{ShowTrend}: valore booleano che indica se visualizzare o meno il trend del contatore.
\end{itemize}
Le \textit{optionsCounter} definiscono le formattazioni da applicare ai valori calcolati (\S \ref{counter-format} \textit{Counter: descrizione}), attraverso l'utilizzo della libreria \textit{numbro.js}. \\
La visualizzazione del trend, determinata dalla variabile \texttt{ShowTrend}, viene attivata nel caso vi fosse un target da raggiungere e i valori elaborati
fossero finiti, modificando il colore del valore del contatore e aggiungendo un'icona in base al raggiungimento o meno del valore di riferimento. \\
In merito al rendere la componente responsiva, è stato utilizzato l'\textit{hook} \\
\texttt{useResizeObserver}, fornito dalla libreria \textit{usehook-ts}, per permettere di
aggiornare il fattore di scala utilizzato per ridimensionare il contenuto in modo da adattarlo alle nuove dimensioni del contenitore attraverso la chiamata alla funzione \texttt{onScale},
un \textit{wrapper} di una funzione anonima tramite l'\textit{hook} \texttt{useDebounceCallback} (fornito sempre dalla libreria \textit{usehook-ts}) utilizzato per evitare chiamate multiple in rapida successione. \\
Tale scala, gestita come stato interno della componente mediante l'\textit{hook} \texttt{useState}, viene passata come parametro alla funzione \texttt{getCounterStyles} invocata nella definizione
dello \texttt{style} del contenitore dei vari elementi che compongono la componente, la quale ritorna un oggetto di proprietà \textit{CSS} necessarie per applicare la trasformazione di scala nei
vari browser.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di Counter viz-lib con target}, width=0.5 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_counter.png}
    \caption{Esempio di \texttt{Counter} \textit{viz-lib} con target}
    \label{fig:counter-example}
\end{figure}

\subsubsection{Chart}
La componente \texttt{Chart} permette di visualizzare i dati passati come \textit{props} alla componente tramite differenti tipologie di grafici. \\
All'interno del \textit{widget} i \textit{props} \texttt{options} vengono elaborati tramite la funzione \\
\texttt{getOptions}, la quale si occupa di definire le opzioni di
default concatenandole con le opzioni fornite. \\
In seguito i \texttt{data}, le \texttt{options} e il \texttt{Layout} vengono ulteriormente preparati tramite il \textit{custom hook} \texttt{usePlotly}. Questo \textit{hook} si
occupa di:
\begin{itemize}
    \item preparare, a partire dalle \textit{props} \texttt{data} e \texttt{options}, i dati nel formato richiesto da \textit{Plotly.js}, ovvero sotto forma di un array di oggetti
          \texttt{Series}, ottenuto tramite la funzione \texttt{getChartData}, comune a tutte le tipologie di grafici;
    \item definire attraverso la funzione \texttt{prepareData} i dati nel formato richiesto a seconda del tipo di grafico configurato all'interno delle opzioni:
          questa funzione si occupa di invocare la corretta funzione di preparazione dei dati, wrappata a sua volta all'interno di una funzione specifica per l'aggiornamento
          delle informazioni;
    \item aggiornare le dimensioni del \textit{widget} in modo responsivo tramite l'utilizzo dell'hoook \texttt{useResizeObserver}, fornito dalla libreria \texttt{usehook-ts},
          invocando \\
          \texttt{useDebounceCallback} della medesima libreria per evitare chiamate multiple in rapida successione al controllo di variazione e aggiornamento
          delle dimensioni del container del grafico;
    \item preparare, a partire dalle props \texttt{options} e dai dati elaborati (comprese le dimensioni del punto precedente), il \textit{layout} del grafico tramite la funzione \\
          \texttt{prepareLayout}, la quale definisce un oggetto parziale del \texttt{Layout} fornito dalla libreria \textit{Plotly.js}. Questa funzione definisce delle opzioni
          di default ed in seguito si occupa di invocare la funzione opportuna a seconda del grafico configurato;
    \item aggiornare il \texttt{Layout} del grafico in base alle dimensioni del \textit{container}, invocando la funzione \texttt{updateChartSize}, la quale si occupa inoltre di stabilire
          il posizionamento più opportuno per la legenda del grafico a seconda dello spazio disponibile.
    \item restituire il risultato elaborato costituito dai \texttt{plotlyData}, dalle \texttt{plotlyOptions} e dal \texttt{plotlyLayout} attraverso un \texttt{useMemo}, in modo da
          gestire in modo efficente il ricalcolo dei dati.
\end{itemize}
Questo \textit{custom hook} permette di gestire le operazioni in modo efficiente, attraverso l'utilizzo di \texttt{useEffect} che garantiscono il calcolo e l'aggiornamento delle informazioni
solamente nel caso di variazione di dati significativi. \\
Il risultato restituito dal \textit{custom hook} \texttt{usePlotly} viene in seguito utilizzato all'interno di un \texttt{useEffect} che lo osserva per effettuare il rendering del grafico
tramite una chiamata asincrona alla funzione \texttt{plot}, contentente a sua volta la chiamata alla funzione \texttt{Plotly.react}, la quale si occupa di renderizzare il grafico all'interno del
\texttt{div} utilizzato come contenitore e riferito mediante l'utilizzo di un \textit{ref} castato al tipo \texttt{PlotlyHTMLElement}, fornito sempre dalla libreria \textit{Plotly.js}. \\
In seguito vengono configurati i \textit{listeners} dichiarati all'interno delle \texttt{options} fornite, permettendo di gestire le interazioni dell'utente di tipo \textit{hover} e \textit{unhover}
sul grafico. Tali \textit{listeners} vengono in seguito smontati correttamente all'interno del \texttt{return} del \texttt{useEffect} per evitare \textit{memory leak} e garantire una corretta gestione
della componente.

\paragraph{Area}
Il grafico ad area (\textit{Area}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{AREA}. \\
La preparazione dei dati avviene in una prima parte invocando la funzione \\
\texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareAreaSeries}, la quale si occupa di definire le informazioni inerenti alla visualizzazione o meno del testo
e la modalità di riempimento dell'area (fino all'asse delle X o fino alla successiva area) a seconda della configurazione della proprietà \texttt{fill} definita nelle serie visualizzata. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali ed eventualmente i valori lungo l'asse delle X, ricalcolando i valori cumulativi per ogni tick. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico ad area viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_area.png}
    \caption{Esempio di grafico ad area (\textit{Area}) \textit{viz-lib}}
    \label{fig:area-example}
\end{figure}

\paragraph{Bar}
Il grafico a barre (\textit{Bar}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{COLUMNS}. \\
La preparazione dei dati avviene in una prima parte invocando la funzione \\
\texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareBarSeries}, la quale si occupa di definire il tipo (\textit{'bar'}) necessario per \textit{Plotly} per comprendere
come interpretare i dati forniti e le informazioni inerenti alla posizione e alla dimensione del testo. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali ed evenutalmente aggiornando i valori lungo l'asse delle X. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico a colonne viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_bar.png}
    \caption{Esempio di grafico a colonne (\textit{Bar}) \textit{viz-lib}}
    \label{fig:bar-example}
\end{figure}

\paragraph{Box}
Il grafico a scatole (\textit{Box}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{BOX}. \\
La preparazione dei dati avviene in una prima parte invocando la funzione \\
\texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareBoxSeries}, la quale si occupa di definire il tipo (\textit{'box'}) necessario per \textit{Plotly} per comprendere
come interpretare i dati forniti e le informazioni inerenti alla visualizzazione dei dati. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali ed evenutalmente aggiornando i valori lungo l'asse delle X. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\paragraph{Bubble}
Il grafico a bolle (\textit{Bubble}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{BUBBLE}. \\
La preparazione dei dati avviene in una prima parte invocando la funzione \\
\texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareBubbleSeries}, la quale si occupa di definire le informazioni inerenti alle bolle, quali le
dimensioni di ciascun dato, il coefficiente di ingrandimento e il riferimento sul come interpretare il valore di dimensionamento fornito. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali ed evenutalmente aggiornando i valori lungo l'asse delle X. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\paragraph{Heatmap}
Il grafico a matrice di calore (\textit{Heatmap}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{HEATMAP}. \\
La preparazione dei dati avviene invocando la funzione \texttt{prepareHeatmapData}, la quale si occupa di definire la scala di colori da utilizzare all'interno del grafico, preparando in seguito le \texttt{Series}
di dati da visualizzare e le relative \texttt{DataLabel} associate, utilizzate per la visualizzazione delle informazioni durante l'\textit{hover}. \\
Per quanto riguarda invece la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo,
come posizione, font, colore e dimensione.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico a matrice di calore viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_heatmap.png}
    \caption{Esempio di grafico a matrice di calore (\textit{Heatmap}) \textit{viz-lib}}
    \label{fig:heatmap-example}
\end{figure}

\paragraph{Line}
Il grafico a linee (\textit{Line}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{LINE}. \\
La preparazione dei dati avviene in una prima parte invocando la funzione \\
\texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareLineSeries}, la quale si occupa di definire il tipo (\textit{'line'}) necessario per \textit{Plotly}
per comprendere come interpretare i dati forniti e le informazioni inerenti alla posizione e alla dimensione del testo. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali, aggiornando eventualmente i valori lungo l'asse delle X e ricalcolando i valori cumulativi per ogni tick. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico a linea viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_line.png}
    \caption{Esempio di grafico a linea (\textit{Line}) \textit{viz-lib}}
    \label{fig:line-example}
\end{figure}

\paragraph{Pie}
Il grafico a torta (\textit{Pie}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{PIE}. \\
La preparazione dei dati avviene invocando la funzione \texttt{preparePieData}, la quale si occupa di definire i colori delle label di testo visualizzate all'interno degli spicchi del grafico: mentre
i colori del grafico vengono ricavati dalle opzioni fornite dal backend, i colori delle label vengono determinati a seconda del contrasto maggiore rispetto al colore di sfondo, in modo da aumentare
la leggibilità e di conseguenza migliorare l'esperienza utente. \\
In seguito all'interno della funzione vengono calcolate le percentuali occupate da ciascuna rappresentazione, configurando inoltre i font utilizzati, le dimensioni dei caratteri, le informazioni da visualizzare
mediante l'\textit{hover} e la dimensione del raggio dell'\textit{hole} del grafico. \\
L'aggiornamento dei dati viene gestito mediante la funzione \texttt{updatePieData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}. \\
Per quanto riguarda invece la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{preparePieLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo,
come posizione, font, colore e dimensione.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico a torta viz-lib}, width=0.8 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_pie.png}
    \caption{Esempio di grafico a torta (\textit{Pie}) \textit{viz-lib}}
    \label{fig:pie-example}
\end{figure}

\paragraph{Scatter}
Il grafico a dispersione (\textit{Scatter}) è una tipologia di grafico visualizzato all'interno della componente \texttt{Chart} quando la proprietà \texttt{globalSeriesType} è impostata a \texttt{SCATTER}. \\
La preparazione dei dati avviene invocando la funzione \texttt{prepareDefaultData}, la quale si occupa di ricavare i valori dei dati da visualizzare e i colori utilizzati, compresi i
colori delle label. In seguito, all'interno della stessa funzione, viene invocata la funzione \texttt{prepareScatterSeries}, la quale si occupa di definire il tipo (\textit{'scatter'}) necessario per \textit{Plotly}
per comprendere come interpretare i dati forniti e le informazioni inerenti alle dimensioni dei punti e alla posizione e dimensione dell'eventuale testo associato. \\
L'aggiornamento dei dati avviene mediante la funzione \texttt{updateDefaultData}, la quale si occupa di aggiornare i testi presenti all'interno delle \texttt{Series} visualizzate, invocando la funzione
\texttt{updateSeriesText}, aggiornando inoltre i valori percentuali ed evenutalmente aggiornando i valori lungo l'asse delle X. \\
Per quanto riguarda la gestione del \texttt{Layout}, viene invocata la funzione \\
\texttt{prepareDefaultLayout}, la quale si occupa di definire le informazioni grafiche inerenti alla legenda e al titolo, come posizione,
font, colore e dimensione, oltre che a preparare l'asse X e l'asse Y a seconda dei valori da visualizzare.

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di grafico con a dispersione (Scatter) e colonne viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_scatter_bar.png}
    \caption{Esempio di grafico a dispersione (\textit{Scatter}) e a colonne (\textit{Bar}) \textit{viz-lib}}
    \label{fig:scatter-example}
\end{figure}

\subsubsection{Table}
La componente \texttt{Table} costituisce una tabella che permette di visualizzare i dati in forma tabellare. \newline
Tale \textit{widget} utilizza \texttt{DataTable}, una componente resa disponibile dalla libreria \textit{PrimeReact} che, attraverso
la definizione di determinate props, rende disponibili le seguenti funzionalità:
\begin{itemize}
    \item alternare i colori delle righe della tabella, al fine di aumentare la leggibilità dei dati visualizzati;
    \item selezionare più righe della tabella, permettendo di effettuare operazioni di \textit{multi-selection} (attraverso
          l'utilizzo di uno \texttt{useState});
    \item impostare un filtro globale per la tabella, permettendo di definire su quali colonne effettuare la ricerca dei dati;
    \item impostare un \textit{empty message} personalizzato, visualizzato nel caso in cui la tabella non contenga dati;
    \item ordinare i dati all'interno delle singole colonne, permettendo di visualizzare i dati in ordine crescente o decrescente.
\end{itemize}
Come introdotto nella sezione (\S \ref{item:hookTable}{ \textit{proprietà della componenti: Table}}), la gestione del filtro globale tramite
la funzione \texttt{onChangeGlobalFilterValue} presenta l'utilizzo di due valori tramite \texttt{useState}:
\begin{itemize}
    \item \texttt{globalFilterValueTmp}: stringa utilizzata per memorizzare il valore del filtro impostato all'interno di una
          componente \texttt{InputText} di \textit{PrimeReact}, aggiornata in tempo reale all'input fornito dell'utente;
    \item \texttt{globalFilterValue}: stringa utilizzata per impostare il valore del filtro globale della tabella, aggiornata
          tramite una chiamata \textit{debounced} di 200 ms per impostare il valore sullo stato. \newline
          (La funzione \texttt{debounced} fa uso dell'hook \texttt{useDebounceCallback} fornito dalla libreria \textit{usehook-ts}).
\end{itemize}
Tramite questa implementazione, il recupero dei dati visualizzati all'interno della tabella viene eseguito correttamente, permettendo di risolvere
il bug presente all'interno della componente \texttt{DataTable}, il quale comportava la perdita di \textit{entry} nel caso in cui il filtro globale subisse
più modifiche in rapida successione. \newline
La tabella è resa \textit{scrollable}, impostando una altezza che viene calcolata in modo responsivo a seconda dello spazio disponibile
all'interno del \textit{widget} in cui è contenuta. \newline
Attraverso la definizione di un \textit{ref} alla componente \texttt{DataTable}, è possibile effettuare il download della tabella in formato
\textit{CSV}, tramite l'utilizzo della funzione \textit{exportCSV} resa disponibile dalla libreria \textit{PrimeReact}: tale funzione viene
invocata tramite un \texttt{Button} posizionato a fianco della componente \texttt{InputText} utilizzata per l'input del filtro globale. \\
\\
\textbf{Elaborazione dati}\newline
I dati renderizzati all'interno della tabella vengono estratti dal \textit{props} \texttt{data}, passando a sua volta alla componente \texttt{DataTable}
l'array \texttt{rows} contenente i dati da visualizzare tramite la prop \texttt{value}. \newline
Le colonne della tabella sono definite a partire dalle \texttt{options} e dai \texttt{data} passati come \textit{props} alla componente \texttt{Table}.
Inizialmente sono ridefinite mediante la funzione \texttt{getOptions}, la quale imposta delle opzioni di default e ordina la visualizzazione delle colonne
in base all'ordine definito nelle \texttt{options}, impostando le proprietà di filtro delle colonne in base alle opzioni indicate, verificando la presenza
di dati all'interno dei \texttt{data} (nel caso di assenza di riscontro vengono definite le colonne a partire dai \texttt{data}).
Successivamente dalle \texttt{options} elaborate vengono definite le vere e proprie colonne della tabella (\textit{tableColumns}), attraverso la funzione \texttt{prepareColumns},
la quale attua il filtraggio delle colonne e costruisce il loro \textit{header} in base alle opzioni elaborate. \newline
Le \texttt{tableColumns} vengono in seguito mappate per creare le componenti \texttt{Column} presentate all'interno della tabelle, impostando:
\begin{itemize}
    \item l'\textit{header} a partire dalle opzioni elaborate;
    \item il \textit{field} a cui fanno riferimento a partire dalle opzioni elaborate;
    \item la \textit{props} \textit{sortable}, utilizzata per permettere l'ordinamento sulla colonna;
    \item la\textit{props} \textit{body}, utilizzata per permettere il corretto formattamento e rendering dei dati visualizzati all'interno della singola colonna,
          invocando la funzione \texttt{formatRowValue}.
\end{itemize}
Le formattazioni dei dati avvengono mediante i \textit{formatter} resi disponibili:
\begin{itemize}
    \item \textit{string}: formatta il testo in base indicazioni presenti nell'item, eventualmente restituendo del contenuto \textit{HTML};
    \item \textit{datetime}: formatta le date in base alle opzioni elaborate mediante l'uso di \textit{day.js};
    \item \textit{number}: formatta i numeri in base alle opzioni elaborate mediante l'uso di \textit{numbro};
    \item \textit{boolean}: formatta i booleani in base alle opzioni fornite, elaborando anche array;
    \item \textit{json}: formatta i dati \textit{JSON} in base alle opzioni fornite, permettendo di visualizzare i dati in modo strutturato;
    \item \textit{image}: formatta le immagini in base alle opzioni fornite, permettendo di visualizzarle all'interno della tabella.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio di Table viz-lib}, width=1 \columnwidth, height=\maxdimen, keepaspectratio]{img/ex_table.png}
    \caption{Esempio di \texttt{Table} \textit{viz-lib}}
    \label{fig:table-example}
\end{figure}

\subsubsection{Renderer}
La componente \textit{Renderer} costituisce l'\textit{entry point} della libreria, permettendo di renderizzare tutte le componenti presenti all'interno di
\textit{viz-lib}: per questo motivo tale componente costituisce l'unico \textit{export} della libreria accessibile all'\textit{index.ts} del SDK. \newline
Tale componente costituisce il \textit{wrap} della componente \textit{RendererR}, ottenuto tramite l'utilizzo della funzione \texttt{React.memo}.
\begin{adjustwidth}{4em}{0pt}
    \texttt{React.memo} è una funzione offerta da \textit{React} per effettuare la \textit{memoization} di una componente funzionale, permettendo di evitare
    nuove renderizzazioni nel caso in cui il componente padre lo richiedesse, a meno che le sue \textit{props} non abbiano subito modifiche. \newline
    Tale funzione accetta due parametri:
    \begin{itemize}
        \item la componente da \textit{memoizzare};
        \item una funzione che accetta due argomenti: le \textit{props} correnti e le \textit{props} precedenti della componente, restituendo un valore booleano che indica
              se la componente debba essere renderizzata o meno.
    \end{itemize}
    La presenza del secondo parametro permette di effettuare un controllo specifico, andando a definire i criteri di cambiamento delle \textit{props}
    rilevanti ai fini della nuova renderizzazione della componente. \newline
\end{adjustwidth}
Nel nostro caso, la funzione \texttt{React.memo} utilizza come criterio di controllo tra le \textit{props} la funzione \texttt{isEqual} resa disponibile da \textit{lodash},
la quale permette di effettuare un confronto profondo tra due valori per determinare se sono equivalenti. \newline
\begin{listing}[H]
    \begin{minted}{typescript}
        const Renderer = React.memo(RendererR, (prev, next) =>
            isEqual(prev.data, next.data)
        );
  \end{minted}
    \caption{\texttt{React.memo} della componente \texttt{Renderer}}
    \label{listing:react_memo}
\end{listing}
Per quanto riguarda la componente \texttt{RendereR} in questione, essa ricava dai suoi \textit{props}, tramite l'utilizzo della funzione \texttt{getVisualizationType}, il valore
dell'enumerazione \texttt{VisualizationType}, assegnandolo alla costante \texttt{visualizationType}, ai fini di renderizzare la componente corretta in base al tipo di
visualizzazione ricevuto come parametro.

\subsection{Documentazione}
L'implementazione della libreria prodotta è stata documentata tramite l'utilizzo di \textit{Confluence}, la piattaforma
di gestione della conoscenza e di collaborazione sviluppata da \textit{Atlassian}. \newline
La documentazione, su richiesta dell'azienda, è stata redatta in lingua inglese, attraverso una descrizione dettagliata
delle componenti e delle funzionalità offerte dalla libreria. \newline

\begin{figure}[H]
    \centering
    \includegraphics[alt={Esempio documentazione \textit{Confluence}}, width=1 \textwidth]{img/ex_confluence.png}
    \caption{Esempio documentazione Confluence}
    \label{fig:ex_confluence}
\end{figure}

La documentazione è stata strutturata in modo da essere facilmente consultabile e comprensibile, con l'obiettivo di
fornire un supporto efficace agli sviluppatori futuri che potrebbero dover utilizzare o lavorare sopra l'SDK implementato. \newline
La produzione di una buona documentazione ricopre infatti un ruolo fondamentale ai fini di garantire la manutenibilità
del codice e la facilità di comprensione delle funzionalità offerte dalla libreria, in modo da ridurre i tempi di
apprendimento e di sviluppo necessari per gli utilizzi futuri del prodotto implementato.

\section{Testing}
Nella presente sezione verranno descritte le attività di testing effettuate durante lo sviluppo della libreria, con l'obiettivo
di garantire la qualità del prodotto implementato e la corretta esecuzione delle funzionalità offerte.

\subsection{Jest}
Lo strumento utilizzato e configurato all'interno del progetto per l'esecuzione dei test è \textit{Jest}, un framework di testing
per \textit{JavaScript} sviluppato da \textit{Facebook}. \newline
\textit{Jest} permette di effettuare test su funzioni, classi e moduli, fornendo un'ampia gamma di funzionalità per la scrittura e l'esecuzione
dei test. \newline
In particolare, \textit{Jest} offre le seguenti funzionalità:
\begin{itemize}
    \item \textbf{Mocking components}: permette di creare \textit{\gls{mock}\glox} di componenti, in modo da simularne il suo comportamento:
          \begin{listing}[H]
              \begin{minted}{typescript}
            jest.mock('percorso.componente', () => ({
                Componente: () => mock_value,
            }));
            \end{minted}
              \caption{Esempio di \textit{mock} di una componente}
              \label{listing:mock_component}
          \end{listing}
    \item \textbf{Mocking function}: permette di creare \textit{mock} di funzioni, in modo da simularne il suo comportamento:
          \begin{listing}[H]
              \begin{minted}{typescript}
                jest.spyOn(file_funzione, 'nomeFunzione')
                    .mockReturnValue(mock_value);
            \end{minted}
              \caption{Esempio di \textit{mock} di una funzione}
              \label{listing:mock_function}
          \end{listing}
    \item \textbf{Suite di test}: permette di creare \textit{suite} di test, organizzando i test in modo gerarchico:
          \begin{listing}[H]
              \begin{minted}{typescript}
                describe('Nome suite di test', () => {
                    it('Nome test', () => {
                        // Codice del test
                    });
                });
            \end{minted}
              \caption{Esempio di \textit{suite} di test}
              \label{listing:test_suite}
          \end{listing}
    \item \textbf{Expect}: permette di effettuare asserzioni sui valori restituiti dalle funzioni, verificando la correttezza
          del risultato ottenuto:
          \begin{listing}[H]
              \begin{minted}{typescript}
                    expect(valore).toBe(valore_aspettato);
                \end{minted}
              \caption{Esempio di \texttt{expect} su valore}
              \label{listing:expect}
          \end{listing}
          oppure di verificare la presenza di un elemento all'interno del \textit{DOM}:
          \begin{listing}[H]
              \begin{minted}{typescript}
                    expect(screen.getByText('Testo')).toBeInTheDocument();
                \end{minted}
              \caption{Esempio di \texttt{expect} su elemento del \textit{DOM}}
              \label{listing:expect_dom}
          \end{listing}
\end{itemize}
La sua configurazione è stata effettuata all'interno del file \textit{packages.json}, in cui sono state definite le impostazioni di
esecuzione dei test e le dipendenze necessarie per il loro corretto funzionamento, come il preset che consente di utilizzare \textit{Typescript},
l'ambiente di test \textit{jsdom} che simula un ambiente browser e i vari formati di file che deve considerare o ignorare. \newline
Di seguito viene riportata la configurazione utilizzata.
\begin{listing}[H]
    \begin{minted}{json}
    "jest": {
        "preset": "ts-jest",
        "testEnvironment": "jsdom",
        "moduleFileExtensions": [
            "ts",
            "tsx",
            "js",
            "jsx",
            "json",
            "node"
        ],
        "transform": {
            "^.+\\.(ts|tsx)$": "ts-jest",
            "^.+\\.(js|jsx)$": "babel-jest"
        },
        "transformIgnorePatterns": [
            "node_modules/(?!(d3-color)/)"
        ]
    }
    \end{minted}
    \caption{Configurazione \textit{Jest} all'interno del file \textit{packages.json}}
    \label{listing:jest_config}
\end{listing}

\subsection{Unit testing}
Per garantire la correttezza delle funzionalità offerte dalla libreria, è stato effettuato un processo di testing a livello di unità. \newline
Nel presente progetto sono stati implementati test per le singole componenti, \textit{mockando} le dipendenze esterne ed eventuali altre componenti
della libreria utilizzate, verificando il corretto funzionamento all'interno della singola unità.

\begin{listing}[H]
    \begin{minted}[escapeinside=||]{typescript}
    jest.mock('./charts/Counter', () => ({
        Counter: () => <div>Counter Component|</|div>,
    }));

    jest.mock('./charts/Chart', () => ({
        Chart: () => <div>Chart Component|</|div>,
    }));

    jest.mock('./charts/Table', () => ({
        Table: () => <div>Table Component|</|div>,
    }));

    describe('Renderer test right components', () => {
        it('renders Counter component when visualizationType is Counter', 
            () => {
            jest.spyOn(helper, 'getVisualizationType')
                .mockReturnValue(VisualizationType.Counter);

            const rendererProps: RendererProps = {
                visualizationName: 'Counter',
                type: 'Counter',
                data: {},
                options: {},
            };

            render(<Renderer {...rendererProps} />);

            expect(screen.getByText('Counter Component')).toBeInTheDocument();
            });
    // ...
    });
    \end{minted}
    \caption{Esempio di \textit{unit test}: \texttt{Renderer} component}
    \label{listing:test_Renderer}
\end{listing}

Come si può osservare nell'esempio di codice riportato, è stato effettuato un test sulla componente \textit{Renderer},
\textit{mockando} le componenti \textit{Counter}, \textit{Chart} e \textit{Table} utilizzate all'interno della componente stessa, verficando che venisse renderizzata
la componente corretta in base al tipo di visualizzazione passato come parametro. \newline
Il tipo di visualizzazione a sua volta viene ottenuto dal \textit{mock} della funzione \\
\texttt{getVisualizationType}, la quale restituisce il tipo di visualizzazione
corretto in base al parametro passato come \textit{props} al \texttt{Renderer}: in questo modo viene garantita la correttezza logica della singola componente, senza far affidamento
su funzioni o componenti esterne. \\ \\
La correttezza delle funzioni è stata verificata tramite appositi test di unità, eventualmente \textit{mockando} le dipendenze esterne utilizzate
all'interno della funzione stessa, in modo da garantire la correttezza nella logica implementata. \newline
Di seguito viene riportato un esempio di test di unità effettuato sulla funzione \\
\texttt{getVisualizationType}.

\begin{listing}[H]
    \begin{minted}{typescript}
    it('should return VisualizationType.Table when type is TABLE', () => {
        expect(
            getVisualizationType('TABLE')
        ).toBe(VisualizationType.Table);
    });
    \end{minted}
    \caption{Esempio di \textit{unit test}: \texttt{getVisualizationType}}
    \label{listing:test_getVisualizationType}
\end{listing}

\subsection{Integration testing}
Per garantire la corretta integrazione delle componenti all'interno della libreria, è stato effettuato un processo di testing a livello di integrazione,
tramite l'utilizzo di \textit{Jest}. \newline
I test di integrazione permettono di verificare il corretto funzionamento delle componenti all'interno del sistema, testando il comportamento
dei singoli moduli all'interno del contesto in cui sono utilizzati.

\begin{listing}[H]
    \begin{minted}[escapeinside=||]{typescript}
    jest.mock('./charts/Counter', () => ({
        Counter: () => <div>Counter Component|</|div>,
    }));

    jest.mock('./charts/Chart', () => ({
        Chart: () => <div>Chart Component|</|div>,
    }));

    jest.mock('./charts/Table', () => ({
        Table: () => <div>Table Component|</|div>,
    }));
    
    describe('Renderer test right components', () => {
        it('renders Counter component when visualizationType is Counter', () => {

            const rendererProps: RendererProps = {
                visualizationName: 'Counter',
                type: 'Counter',
                data: {},
                options: {},
            };

            render(<Renderer {...rendererProps} />);

            expect(screen.getByText('Counter Component')).toBeInTheDocument();
        });
    // ...
    });
    \end{minted}
    \caption{Esempio di \textit{integration test}: \texttt{Renderer} component}
    \label{listing:test_Renderer_integration}
\end{listing}

Come si può osservare nell'esempio di codice riportato, è stato effettuato un test di integrazione sulla componente \texttt{Renderer},
\textit{mockando} le componenti \texttt{Counter}, \texttt{Chart} e \texttt{Table} utilizzate all'interno della componente stessa, verficando che venisse renderizzata
la componente corretta in base al tipo di visualizzazione passato come parametro. \newline
Il tipo di visualizzazione a sua volta viene ottenuto internamente alla componente grazie alla funzione \texttt{getVisualizationType}, la quale restituisce il tipo di visualizzazione
corretto in base al parametro ricevuto come \textit{props} dal \texttt{Renderer}: in questo modo viene garantita la corretta integrazione delle componenti all'interno del sistema, testando il comportamento
delle unità in relazione tra loro all'interno del contesto in cui sono utilizzate.